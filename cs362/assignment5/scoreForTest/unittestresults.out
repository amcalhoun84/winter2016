STANDARDIZED TESTS:
INITIALIZE GAME: 2 players... deck initialized.... state and memory allocated.
State Coins: 4
Empty Hand, No Bonus Cash.
Test #1 Passed.
Empty hand, 10 coin bonus.
Test #2 Passed.
Empty hand, randomized bonus.
Test #3 Passed.
No coins, negative bonus.
Test #4 Passed.
Two Coppers, Two Silver, No Bonus.
Test #4 Passed!
Same test, two bonus.
Test #5 Passed!
Fully Randomized Tests
State Gold (Expected): 10
Player Gold (Result): 10
Randomized Test Passed.
State Gold (Expected): 9
Player Gold (Result): 9
Randomized Test Passed.
State Gold (Expected): 13
Player Gold (Result): 13
Randomized Test Passed.
State Gold (Expected): 15
Player Gold (Result): 15
Randomized Test Passed.
State Gold (Expected): 12
Player Gold (Result): 12
Randomized Test Passed.
State Gold (Expected): 7
Player Gold (Result): 7
Randomized Test Passed.
State Gold (Expected): 10
Player Gold (Result): 10
Randomized Test Passed.
State Gold (Expected): 12
Player Gold (Result): 12
Randomized Test Passed.
State Gold (Expected): 8
Player Gold (Result): 8
Randomized Test Passed.
State Gold (Expected): 11
Player Gold (Result): 11
Randomized Test Passed.
Tests Run: 16
Tests Passed: 16
Tests Failed: 0
Randomized Test Fail Value: 0
All Random Tests Passed!

Testing the Discard Card Function
All assertions passed #1.
All assertions passed #2.
All assertions passed #3.
TESTS OK!

Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

You have no buys left. 0 Buy Test Passed.

Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Card supply available.
Can buy card with available gold. Yes!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!
Testing Buy Card Functionality

One or more buys available test passed.
Out of that particular card!


All tests passed!
Assertions to ensure cards are discarded properly at end of each turn.
Post Turn End: 5
 Pre Turn End: 5
Discard Assertions passed.
Player Counts -- makes sure player is properly selected.
Player Turn Counter Works Correctly
Assertion Tests for Outposts, Action Counts, and Coins. All Should Be Equal.
All assertions passed.
Testing Adventurer!

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 1
Deck shuffled at 1. Test Failed.
Treasure Draw Check Failed.Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 6
One or More Assertion and Gameplay Tests Failed.

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 0
Deck shuffled at 0 properly. Test Passed.
Treasure Draw Check Failed.Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 6
One or More Assertion and Gameplay Tests Failed.

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 1
Deck shuffled at 1. Test Failed.
Treasure Draw Check Failed.Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 5
One or More Assertion and Gameplay Tests Failed.

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 0
Deck shuffled at 0 properly. Test Passed.
Treasure Draw Check Failed.Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 6
One or More Assertion and Gameplay Tests Failed.

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 0
Deck shuffled at 0 properly. Test Passed.
Treasure Draw Check Failed.Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 5
One or More Assertion and Gameplay Tests Failed.

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 1
Deck shuffled at 1. Test Failed.
Treasure Draw Check Failed.Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 5
One or More Assertion and Gameplay Tests Failed.

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 1
Deck shuffled at 1. Test Failed.
Treasure Draw Check Failed.Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 6
One or More Assertion and Gameplay Tests Failed.

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 2
No shuffle. Test Passed.
Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 5
All Assertion and Gameplay Tests Passed!

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 2
No shuffle. Test Passed.
Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 5
All Assertion and Gameplay Tests Passed!

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 2
No shuffle. Test Passed.
Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 5
All Assertion and Gameplay Tests Passed!

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 0
Deck shuffled at 0 properly. Test Passed.
Treasure Draw Check Failed.Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 6
One or More Assertion and Gameplay Tests Failed.

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 2
No shuffle. Test Passed.
Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 5
All Assertion and Gameplay Tests Passed!

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 2
No shuffle. Test Passed.
Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 5
All Assertion and Gameplay Tests Passed!

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 2
No shuffle. Test Passed.
Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 5
All Assertion and Gameplay Tests Passed!

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 0
Deck shuffled at 0 properly. Test Passed.
Treasure Draw Check Failed.Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 6
One or More Assertion and Gameplay Tests Failed.

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 0
Deck shuffled at 0 properly. Test Passed.
Treasure Draw Check Failed.Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 5
One or More Assertion and Gameplay Tests Failed.

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 2
No shuffle. Test Passed.
Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 5
All Assertion and Gameplay Tests Passed!

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 2
No shuffle. Test Passed.
Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 5
All Assertion and Gameplay Tests Passed!

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 0
Deck shuffled at 0 properly. Test Passed.
Treasure Draw Check Failed.Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 6
One or More Assertion and Gameplay Tests Failed.

Checking Drawn Treasure.
Drawn Treasure: 0
Initiating randomized deckCount: 1-5
Deck Count: 1
Deck shuffled at 1. Test Failed.
Treasure Draw Check Failed.Testing Coins. Should only add 1

State Coin Test passed.
Previous Hand Count: 5
Current Hand Count: 5
One or More Assertion and Gameplay Tests Failed.
Successes / Tests Run: 8 / 20
Failures / Tests Run: 12 / 20
Testing Smithy!
Player 1 Test -- GIVING SMITHYGiving Smithy Test Passed.
Position 0, Card: 4
Position 1, Card: 4
Position 2, Card: 4
Position 3, Card: 4
Position 4, Card: 4
DECK COUNTED
DISCARD COUNT -- SHOULD BE 0
Discard Successful. Count successful.
Position 0, card: 1
Position 1, card: 4
Position 2, card: 1
Position 3, card: 4
Position 4, card: 1
Position 5, card: 13
Smithy Granted Hand Count: 6
Pre-Smithy Granted Hand Count: 5
Smithy did not add expected number of cards.
Expected Hand Count: 9
Result: 8
Testing Card Discard.
Discard test and check passed.
Checking expected seed state.
Position 0 Deck Card: 4
Position 1 Deck Card: 4
Position 2 Deck Card: 4
Position 3 Deck Card: 4
Position 4 Deck Card: 4
Test failed. Please check code or revise seed.
Checking hand and seed state.
Test Passed.

Player 2 Tests ----- Making sure everything looks good for their turn.

DECK RECOUNT
Position 0, Card: 4
Position 1, Card: 1
Position 2, Card: 4
Position 3, Card: 4
Position 4, Card: 4
Position 5, Card: 1
Position 6, Card: 1
Position 7, Card: 4
Position 8, Card: 4
Position 9, Card: 4
Player has 10 card count Test.
Player has proper number of cards.
Smithy properly granted to player and player card count incremented.
One or more tests failed. Please review outputs and revise code.
Smithy card did not work properly. Please revise code.
Smithy gave: 8
Expected: 9
TEST #1: Assert that each victory card has 8 cards in the supply, if not, abort program.
Potential issue is base game is modified. Please reload base files if game has been altered.k[0] count: 10
k[1] count: 10
k[2] count: 8
k[3] count: 10
k[4] count: 10
k[5] count: 8
k[6] count: 10
k[7] count: 10
k[8] count: 10
k[9] count: 10
Kingdom Card Supplies All Correct
TEST #2: Testing Num Action and Card Draw Increases...
TEST #2: Cards Drawn Properly Increased.
TEST #2: Number of actions are properly increased.
TEST #3: Discard Test
TEST #3: Discard Test Failed!
Expected: 1
Result: 0

One or more tests failed, please review results and revise code.

TEST #1: Minion Card - choice1 = 1, choice 2 = 0
Checking to see if action was added...TEST #1: Action Test failed!
Expected: 2
Result: 0

Checking to see if 2 coins were added...
TEST #1: Coin Test failed!
 That dirty minion stole or forgot to give us coins!
Expected: 12
Result: 8

Discard Count: 0
Discards: 0
TEST #1: Discard Test Passed.
TEST #1: Previous Hand Count: 5
TEST #1: Current Hand Count: 4
TEST #1: Hand Count Test passed.

Checking to see if other players drew cards. (Should Not if Choice 1 was Picked)
Number of Cards in Hand for Player 2: 0
TEST #1: Player Draw Test passed.

Resetting values...

MINION TEST #2: Checking Choice 2...
Checking to see if action was added...
TEST #2: Test failed!
Expected: 2
Result: 0

Testing to see if 2 coins were added...
 -- They should not be if choice2 = true
TEST #2: Coin Test passed!

TEST #2: Checking discard. Should be greater than 0.
TEST #2: Test failed.

TEST #2: Checking to see that 4 cards were drawn for player 1

TEST #2: Draw Test failed!
Expected: 9
Result: 7

TEST #2: Checking Hand Counts for other Players.
Player 2: Hand Count: 0
TEST #2: Other Player Hand Count Test Passed.

Expected: 4
Result: 0
One or more tests failed! Please review results and revise code.
File 'dominion.c'
Lines executed:29.74% of 575
dominion.c:creating 'dominion.c.gcov'

// Assignment 2, CS362-400-W16
// Andrew M. Calhoun
// calhouna@oregonstate.edu
// Due Date: 1/17/2016

#include "dominion.h"
#include "dominion_helpers.h"
#include "rngs.h"
#include <stdio.h>
#include <math.h>
#include <stdlib.h>



int compare(const void* a, const void* b) {
  if (*(int*)a > *(int*)b)
    return 1;
  if (*(int*)a < *(int*)b)
    return -1;
  return 0;
}

struct gameState* newGame() {
  struct gameState* g = malloc(sizeof(struct gameState));
  return g;
}

int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
		  int k8, int k9, int k10) {
  int* k = malloc(10 * sizeof(int));
  k[0] = k1;
  k[1] = k2;
  k[2] = k3;
  k[3] = k4;
  k[4] = k5;
  k[5] = k6;
  k[6] = k7;
  k[7] = k8;
  k[8] = k9;
  k[9] = k10;
  return k;
}

int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
		   struct gameState *state) {

  int i;
  int j;
  int it;
  //set up random number generator
  SelectStream(1);
  PutSeed((long)randomSeed);

  //check number of players
  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
    {
      return -1;
    }

  //set number of players
  state->numPlayers = numPlayers;

  //check selected kingdom cards are different
  for (i = 0; i < 10; i++)
    {
      for (j = 0; j < 10; j++)
        {
	  if (j != i && kingdomCards[j] == kingdomCards[i])
	    {
	      return -1;
	    }
        }
    }


  //initialize supply
  ///////////////////////////////

  //set number of Curse cards
  if (numPlayers == 2)
    {
      state->supplyCount[curse] = 10;
    }
  else if (numPlayers == 3)
    {
      state->supplyCount[curse] = 20;
    }
  else
    {
      state->supplyCount[curse] = 30;
    }

  //set number of Victory cards
  if (numPlayers == 2)
    {
      state->supplyCount[estate] = 8;
      state->supplyCount[duchy] = 8;
      state->supplyCount[province] = 8;
    }
  else
    {
      state->supplyCount[estate] = 12;
      state->supplyCount[duchy] = 12;
      state->supplyCount[province] = 12;
    }

  //set number of Treasure cards
  state->supplyCount[copper] = 60 - (7 * numPlayers);
  state->supplyCount[silver] = 40;
  state->supplyCount[gold] = 30;

  //set number of Kingdom cards
  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
    {
      for (j = 0; j < 10; j++)           		//loop chosen cards
	{
	  if (kingdomCards[j] == i)
	    {
	      //check if card is a 'Victory' Kingdom card
	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
		{
		  if (numPlayers == 2){
		    state->supplyCount[i] = 8;
		  }
		  else{ state->supplyCount[i] = 12; }
		}
	      else
		{
		  state->supplyCount[i] = 10;
		}
	      break;
	    }
	  else    //card is not in the set choosen for the game
	    {
	      state->supplyCount[i] = -1;
	    }
	}

    }

  ////////////////////////
  //supply initialization complete

  //set player decks
  for (i = 0; i < numPlayers; i++)
    {
      state->deckCount[i] = 0;
      for (j = 0; j < 3; j++)
	{
	  state->deck[i][j] = estate;
	  state->deckCount[i]++;
	}
      for (j = 3; j < 10; j++)
	{
	  state->deck[i][j] = copper;
	  state->deckCount[i]++;
	}
    }

  //shuffle player decks
  for (i = 0; i < numPlayers; i++)
    {
      if ( shuffle(i, state) < 0 )
	{
	  return -1;
	}
    }

  //draw player hands
  for (i = 0; i < numPlayers; i++)
    {
      //initialize hand size to zero
      state->handCount[i] = 0;
      state->discardCount[i] = 0;
      //draw 5 cards
      // for (j = 0; j < 5; j++)
      //	{
      //	  drawCard(i, state);
      //	}
    }

  //set embargo tokens to 0 for all supply piles
  for (i = 0; i <= treasure_map; i++)
    {
      state->embargoTokens[i] = 0;
    }

  //initialize first player's turn
  state->outpostPlayed = 0;
  state->phase = 0;
  state->numActions = 1;
  state->numBuys = 1;
  state->playedCardCount = 0;
  state->whoseTurn = 0;
  state->handCount[state->whoseTurn] = 0;
  //int it; move to top

  //Moved draw cards to here, only drawing at the start of a turn
  for (it = 0; it < 5; it++){
    drawCard(state->whoseTurn, state);
  }

  updateCoins(state->whoseTurn, state, 0);

  return 0;
}

int shuffle(int player, struct gameState *state) {


  int newDeck[MAX_DECK];
  int newDeckPos = 0;
  int card;
  int i;

  if (state->deckCount[player] < 1)
    return -1;
  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */

  while (state->deckCount[player] > 0) {
    card = floor(Random() * state->deckCount[player]);
    newDeck[newDeckPos] = state->deck[player][card];
    newDeckPos++;
    for (i = card; i < state->deckCount[player]-1; i++) {
      state->deck[player][i] = state->deck[player][i+1];
    }
    state->deckCount[player]--;
  }
  for (i = 0; i < newDeckPos; i++) {
    state->deck[player][i] = newDeck[i];
    state->deckCount[player]++;
  }

  return 0;
}

int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
{
  int card;
  int coin_bonus = 0; 		//tracks coins gain from actions

  //check if it is the right phase
  if (state->phase != 0)
    {
      return -1;
    }

  //check if player has enough actions
  if ( state->numActions < 1 )
    {
      return -1;
    }

  //get card played
  card = handCard(handPos, state);

  //check if selected card is an action
  if ( card < adventurer || card > treasure_map )
    {
      return -1;
    }

  //play card
  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
    {
      return -1;
    }

  //reduce number of actions
  state->numActions--;

  //update coins (Treasure cards may be added with card draws)
  updateCoins(state->whoseTurn, state, coin_bonus);

  return 0;
}

int buyCard(int supplyPos, struct gameState *state) {
  int who;
  if (DEBUG){
    printf("Entering buyCard...\n");
  }

  // I don't know what to do about the phase thing.

  who = state->whoseTurn;

  if (state->numBuys < 1){
    if (DEBUG)
      printf("You do not have any buys left\n");
    return -1;
  } else if (supplyCount(supplyPos, state) <1){
    if (DEBUG)
      printf("There are not any of that type of card left\n");
    return -1;
  } else if (state->coins < getCost(supplyPos)){
    if (DEBUG)
      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    return -1;
  } else {
    state->phase=1;
    //state->supplyCount[supplyPos]--;
    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)

    state->coins = (state->coins) - (getCost(supplyPos));
    state->numBuys--;
    if (DEBUG)
      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
  }

  //state->discard[who][state->discardCount[who]] = supplyPos;
  //state->discardCount[who]++;

  return 0;
}

int numHandCards(struct gameState *state) {
  return state->handCount[ whoseTurn(state) ];
}

int handCard(int handPos, struct gameState *state) {
  int currentPlayer = whoseTurn(state);
  return state->hand[currentPlayer][handPos];
}

int supplyCount(int card, struct gameState *state) {
  return state->supplyCount[card];
}

int fullDeckCount(int player, int card, struct gameState *state) {
  int i;
  int count = 0;

  for (i = 0; i < state->deckCount[player]; i++)
    {
      if (state->deck[player][i] == card) count++;
    }

  for (i = 0; i < state->handCount[player]; i++)
    {
      if (state->hand[player][i] == card) count++;
    }

  for (i = 0; i < state->discardCount[player]; i++)
    {
      if (state->discard[player][i] == card) count++;
    }

  return count;
}

int whoseTurn(struct gameState *state) {
  return state->whoseTurn;
}

int endTurn(struct gameState *state) {
  int k;
  int i;
  int currentPlayer = whoseTurn(state);

  //Discard hand
  for (i = 0; i < state->handCount[currentPlayer]; i++){
    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    state->hand[currentPlayer][i] = -1;//Set card to -1
  }
  state->handCount[currentPlayer] = 0;//Reset hand count

  //Code for determining the player
  if (currentPlayer < (state->numPlayers - 1)){
    state->whoseTurn = currentPlayer + 1;//Still safe to increment
  }
  else{
    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
  }

  state->outpostPlayed = 0;
  state->phase = 0;
  state->numActions = 1;
  state->coins = 0;
  state->numBuys = 1;
  state->playedCardCount = 0;
  state->handCount[state->whoseTurn] = 0;

  //int k; move to top
  //Next player draws hand
  for (k = 0; k < 5; k++){
    drawCard(state->whoseTurn, state);//Draw a card
  }

  //Update money
  updateCoins(state->whoseTurn, state , 0);

  return 0;
}

int isGameOver(struct gameState *state) {
  int i;
  int j;

  //if stack of Province cards is empty, the game ends
  if (state->supplyCount[province] == 0)
    {
      return 1;
    }

  //if three supply pile are at 0, the game ends
  j = 0;
  for (i = 0; i < 25; i++)
    {
      if (state->supplyCount[i] == 0)
	{
	  j++;
	}
    }
  if ( j >= 3)
    {
      return 1;
    }

  return 0;
}

int scoreFor (int player, struct gameState *state) {

  int i;
  int score = 0;
  //score from hand
  for (i = 0; i < state->handCount[player]; i++)
    {
      if (state->hand[player][i] == curse) { score = score - 1; };
      if (state->hand[player][i] == estate) { score = score + 1; };
      if (state->hand[player][i] == duchy) { score = score + 3; };
      if (state->hand[player][i] == province) { score = score + 6; };
      if (state->hand[player][i] == great_hall) { score = score + 1; };
      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    }

  //score from discard
  for (i = 0; i < state->discardCount[player]; i++)
    {
      if (state->discard[player][i] == curse) { score = score - 1; };
      if (state->discard[player][i] == estate) { score = score + 1; };
      if (state->discard[player][i] == duchy) { score = score + 3; };
      if (state->discard[player][i] == province) { score = score + 6; };
      if (state->discard[player][i] == great_hall) { score = score + 1; };
      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    }

  //score from deck
  for (i = 0; i < state->discardCount[player]; i++)
    {
      if (state->deck[player][i] == curse) { score = score - 1; };
      if (state->deck[player][i] == estate) { score = score + 1; };
      if (state->deck[player][i] == duchy) { score = score + 3; };
      if (state->deck[player][i] == province) { score = score + 6; };
      if (state->deck[player][i] == great_hall) { score = score + 1; };
      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
    }

  return score;
}

int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
  int i;
  int j;
  int highScore;
  int currentPlayer;

  //get score for each player
  for (i = 0; i < MAX_PLAYERS; i++)
    {
      //set unused player scores to -9999
      if (i >= state->numPlayers)
	{
	  players[i] = -9999;
	}
      else
	{
	  players[i] = scoreFor (i, state);
	}
    }

  //find highest score
  j = 0;
  for (i = 0; i < MAX_PLAYERS; i++)
    {
      if (players[i] > players[j])
	{
	  j = i;
	}
    }
  highScore = players[j];

  //add 1 to players who had less turns
  currentPlayer = whoseTurn(state);
  for (i = 0; i < MAX_PLAYERS; i++)
    {
      if ( players[i] == highScore && i > currentPlayer )
	{
	  players[i]++;
	}
    }

  //find new highest score
  j = 0;
  for (i = 0; i < MAX_PLAYERS; i++)
    {
      if ( players[i] > players[j] )
	{
	  j = i;
	}
    }
  highScore = players[j];

  //set winners in array to 1 and rest to 0
  for (i = 0; i < MAX_PLAYERS; i++)
    {
      if ( players[i] == highScore )
	{
	  players[i] = 1;
	}
      else
	{
	  players[i] = 0;
	}
    }

  return 0;
}

int drawCard(int player, struct gameState *state)
{	int count;
  int deckCounter;
  if (state->deckCount[player] <= 0){//Deck is empty

    //Step 1 Shuffle the discard pile back into a deck
    int i;
    //Move discard to deck
    for (i = 0; i < state->discardCount[player];i++){
      state->deck[player][i] = state->discard[player][i];
      state->discard[player][i] = -1;
    }

    state->deckCount[player] = state->discardCount[player];
    state->discardCount[player] = 0;//Reset discard

    //Shufffle the deck
    shuffle(player, state);//Shuffle the deck up and make it so that we can draw

    if (DEBUG){//Debug statements
      printf("Deck count now: %d\n", state->deckCount[player]);
    }

    state->discardCount[player] = 0;

    //Step 2 Draw Card
    count = state->handCount[player];//Get current player's hand count

    if (DEBUG){//Debug statements
      printf("Current hand count: %d\n", count);
    }

    deckCounter = state->deckCount[player];//Create a holder for the deck count

    if (deckCounter == 0)
      return -1;

    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    state->deckCount[player]--;
    state->handCount[player]++;//Increment hand count
  }

  else{
    int count = state->handCount[player];//Get current hand count for player
    int deckCounter;
    if (DEBUG){//Debug statements
      printf("Current hand count: %d\n", count);
    }

    deckCounter = state->deckCount[player];//Create holder for the deck count
    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
    state->deckCount[player]--;
    state->handCount[player]++;//Increment hand count
  }

  return 0;
}

// PLAY CARD FUNCTIONS ----------------------------------------------------------------------------------------------
//
// PLAY ADVENTURER
//

int playAdventurer(struct gameState *state, int currentPlayer, int cardDrawn, int drawntreasure, int temphand[], int z)
{

      while(drawntreasure<2){
	if (state->deckCount[currentPlayer] <=1){//if the deck is empty we need to shuffle discard and add to deck *** REFACTOR to <= will cause additional shuffling.
	  shuffle(currentPlayer, state);
	}
	drawCard(currentPlayer, state);
	cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
	if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
	  drawntreasure+=2; // The adventurer should not make off with your treasure. Originally had this put as --, but it actually caused the game to freeze. Opted to give the player more coins. Changes seeded outcomes.
	else{
	  temphand[z]=cardDrawn;
	  state->handCount[currentPlayer]++; //this should just remove the top card (the most recently drawn one).
	  z++;
	}
      }
      while(z-1>=0){
	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
	z=z-1;
      }
      return 0;
}

//---------------------
// PLAY COUNCIL HALL
//---------------------
int playCouncRoom(struct gameState *state, int currentPlayer, int handPos)
{
    int i; // Needed to be declared under C99 standards, otherwise program breaks.

    //+4 Cards ** REFACTORED TO 3 because of introduced bug.
    for (i = 0; i < 4; ++i)
	{
	  drawCard(currentPlayer, state);
	}

      //+1 Buy
      state->numBuys++;

      //Each other player draws a card
      for (i = 0; i < state->numPlayers; i++)
	{
	  if ( i != currentPlayer )
	    {
	      drawCard(i, state);
	    }
	}

      //put played card in played card pile
    discardCard(handPos, currentPlayer, state, 0);

    return 0;
}

//-------------------------------
// PLAY MINION
//-------------------------------

int playMinion(struct gameState *state, int choice1, int choice2, int currentPlayer, int handPos)
{

    int i, j;


      //+1 action
      state->numActions--;

      //discard card from hand
      discardCard(handPos, currentPlayer, state, 0);

      if (choice1)		//+2 coins *** REFACTORED: -2 coins.
	{
	  state->coins = state->coins - 2;
	}

      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
	{

//	  //discard hand ** COMMENTED OUT FOR REFACTORING
//	  while(numHandCards(state) > 0)
//	    {
//	      discardCard(handPos, currentPlayer, state, 0);
//	    }

	  //draw 4 *** REFACTORED TO DRAW 3
	  for (i = 0; i < 3; i++)
	    {
	      drawCard(currentPlayer, state);
	    }

	  //other players discard hand and redraw if hand size > 4 *** REFACTOR: They not only get to keep their cards, they get 3 MORE!
	  for (i = 0; i < state->numPlayers; i++)
	    {
	      if (i != currentPlayer)
		{
		  if ( state->handCount[i] > 4 )
		    {
		    //  //discard hand
		    //  while( state->handCount[i] > 0 )
			// {
			//  discardCard(handPos, i, state, 0);
			// }

		      //draw 4 ** REFACTOR: 3
		      for (j = 0; j < 3; j++)
			{
			  drawCard(i, state);
			}
		    }
		}
	    }

	}
      return 0;

}

//-------------------------------
// PLAY SMITHY
//-------------------------------

int playSmithy(struct gameState *state, int currentPlayer, int handPos)
{

    int i;

//+3 Cards  *** REFACTOR changes i++ to ++i, breaks the intent of the card.
      for (i = 0; i < 3; ++i)
	{
	  drawCard(currentPlayer, state);
	}
      //discard card from hand
      discardCard(handPos, currentPlayer, state, 0);
      return 0;
}


//-------------------------------
// VILLAGE
//-------------------------------

int playVillage(struct gameState *state, int currentPlayer, int handPos)
{
      //+1 Card
      drawCard(currentPlayer, state);

      //+2 Actions
      state->numActions = state->numActions + 2;

      //discard played card from hand
      // discardCard(handPos, currentPlayer, state, 0);
      return 0;

}

//---------------------------------

int getCost(int cardNumber)
{
  switch( cardNumber )
    {
    case curse:
      return 0;
    case estate:
      return 2;
    case duchy:
      return 5;
    case province:
      return 8;
    case copper:
      return 0;
    case silver:
      return 3;
    case gold:
      return 6;
    case adventurer:
      return 6;
    case council_room:
      return 5;
    case feast:
      return 4;
    case gardens:
      return 4;
    case mine:
      return 5;
    case remodel:
      return 4;
    case smithy:
      return 4;
    case village:
      return 3;
    case baron:
      return 4;
    case great_hall:
      return 3;
    case minion:
      return 5;
    case steward:
      return 3;
    case tribute:
      return 5;
    case ambassador:
      return 3;
    case cutpurse:
      return 4;
    case embargo:
      return 2;
    case outpost:
      return 5;
    case salvager:
      return 4;
    case sea_hag:
      return 4;
    case treasure_map:
      return 4;
    }

  return -1;
}

int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
{
  int i;
  int j;
  int k;
  int x;
  int index;
  int currentPlayer = whoseTurn(state);
  int nextPlayer = currentPlayer + 1;

  int tributeRevealedCards[2] = {-1, -1};
  int temphand[MAX_HAND];// moved above the if statement
  int drawntreasure=0;
  int cardDrawn;
  int z = 0;// this is the counter for the temp hand
  if (nextPlayer > (state->numPlayers - 1)){
    nextPlayer = 0;
  }


switch(card)
{
//------------------------------------------------------------------------------
// Refactored cards/card function calls.

//----------------------------
// ADVENTURER
    case adventurer:
        playAdventurer(state, currentPlayer, cardDrawn, drawntreasure, temphand, z);
        break;
//----------------------------


//--------------------------------
// COUNCIL ROOM
    case council_room:
        playCouncRoom(state, currentPlayer, handPos);
        break;
//---------------------------------

//---------------------------
// MINION
//---------------------------

    case minion:
        playMinion(state, choice1, choice2, currentPlayer, handPos);
        break;
//--------------------------------

//-------------------------
// SMITHY
//-------------------------

case smithy:
      playSmithy(state, currentPlayer, handPos);
      break;

//-------------------------

//-------------------------
// VILLAGE
//-------------------------

case village:
    playVillage(state, currentPlayer, handPos);
    break;

//-------------------------
    case feast:
      //gain card with cost up to 5
      //Backup hand
      for (i = 0; i <= state->handCount[currentPlayer]; i++){
	temphand[i] = state->hand[currentPlayer][i];//Backup card
	state->hand[currentPlayer][i] = -1;//Set to nothing
      }
      //Backup hand

      //Update Coins for Buy
      updateCoins(currentPlayer, state, 5);
      x = 1;//Condition to loop on
      while( x == 1) {//Buy one card
	if (supplyCount(choice1, state) <= 0){
	  if (DEBUG)
	    printf("None of that card left, sorry!\n");

	  if (DEBUG){
	    printf("Cards Left: %d\n", supplyCount(choice1, state));
	  }
	}
	else if (state->coins < getCost(choice1)){
	  printf("That card is too expensive!\n");

	  if (DEBUG){
	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
	  }
	}
	else{

	  if (DEBUG){
	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
	  }

	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
	  x = 0;//No more buying cards

	  if (DEBUG){
	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
	  }

	}
      }

      //Reset Hand
      for (i = 0; i <= state->handCount[currentPlayer]; i++){
	state->hand[currentPlayer][i] = temphand[i];
	temphand[i] = -1;
      }
      //Reset Hand

      return 0;

    case gardens:
      return -1;

    case mine:
      j = state->hand[currentPlayer][choice1];  //store card we will trash

      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
	{
	  return -1;
	}

      if (choice2 > treasure_map || choice2 < curse)
	{
	  return -1;
	}

      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
	{
	  return -1;
	}

      gainCard(choice2, state, 2, currentPlayer);

      //discard card from hand
      discardCard(handPos, currentPlayer, state, 0);

      //discard trashed card
      for (i = 0; i < state->handCount[currentPlayer]; i++)
	{
	  if (state->hand[currentPlayer][i] == j)
	    {
	      discardCard(i, currentPlayer, state, 0);
	      break;
	    }
	}

      return 0;

    case remodel:
      j = state->hand[currentPlayer][choice1];  //store card we will trash

      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
	{
	  return -1;
	}

      gainCard(choice2, state, 0, currentPlayer);

      //discard card from hand
      discardCard(handPos, currentPlayer, state, 0);

      //discard trashed card
      for (i = 0; i < state->handCount[currentPlayer]; i++)
	{
	  if (state->hand[currentPlayer][i] == j)
	    {
	      discardCard(i, currentPlayer, state, 0);
	      break;
	    }
	}


      return 0;

 case baron:
      state->numBuys++;//Increase buys by 1!
      if (choice1 > 0){//Boolean true or going to discard an estate
	int p = 0;//Iterator for hand!
	int card_not_discarded = 1;//Flag for discard set!
	while(card_not_discarded){
	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
	    state->coins += 4;//Add 4 coins to the amount of coins
	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
	    state->discardCount[currentPlayer]++;
	    for (;p < state->handCount[currentPlayer]; p++){
	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
	    }
	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
	    state->handCount[currentPlayer]--;
	    card_not_discarded = 0;//Exit the loop
	  }
	  else if (p > state->handCount[currentPlayer]){
	    if(DEBUG) {
	      printf("No estate cards in your hand, invalid choice\n");
	      printf("Must gain an estate if there are any\n");
	    }
	    if (supplyCount(estate, state) > 0){
	      gainCard(estate, state, 0, currentPlayer);
	      state->supplyCount[estate]--;//Decrement estates
	      if (supplyCount(estate, state) == 0){
		isGameOver(state);
	      }
	    }
	    card_not_discarded = 0;//Exit the loop
	  }

	  else{
	    p++;//Next card
	  }
	}
      }

      else{
	if (supplyCount(estate, state) > 0){
	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
	  state->supplyCount[estate]--;//Decrement Estates
	  if (supplyCount(estate, state) == 0){
	    isGameOver(state);
	  }
	}
      }


      return 0;



    case great_hall:
      //+1 Card
      drawCard(currentPlayer, state);

      //+1 Actions
      state->numActions++;

      //discard card from hand
      discardCard(handPos, currentPlayer, state, 0);
      return 0;

    case steward:
      if (choice1 == 1)
	{
	  //+2 cards
	  drawCard(currentPlayer, state);
	  drawCard(currentPlayer, state);
	}
      else if (choice1 == 2)
	{
	  //+2 coins
	  state->coins = state->coins + 2;
	}
      else
	{
	  //trash 2 cards in hand
	  discardCard(choice2, currentPlayer, state, 1);
	  discardCard(choice3, currentPlayer, state, 1);
	}

      //discard card from hand
      discardCard(handPos, currentPlayer, state, 0);
      return 0;

    case tribute:
      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
	if (state->deckCount[nextPlayer] > 0){
	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
	  state->deckCount[nextPlayer]--;
	}
	else if (state->discardCount[nextPlayer] > 0){
	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
	  state->discardCount[nextPlayer]--;
	}
	else{
	  //No Card to Reveal
	  if (DEBUG){
	    printf("No cards to reveal\n");
	  }
	}
      }

      else{
	if (state->deckCount[nextPlayer] == 0){
	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
	    state->deckCount[nextPlayer]++;
	    state->discard[nextPlayer][i] = -1;
	    state->discardCount[nextPlayer]--;
	  }

	  shuffle(nextPlayer,state);//Shuffle the deck
	}
	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
	state->deckCount[nextPlayer]--;
	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
	state->deckCount[nextPlayer]--;
      }

      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one
	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
	state->playedCardCount++;
	tributeRevealedCards[1] = -1;
      }

      for (i = 0; i <= 2; i ++){
	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
	  state->coins += 2;
	}

	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
	  drawCard(currentPlayer, state);
	  drawCard(currentPlayer, state);
	}
	else{//Action Card
	  state->numActions = state->numActions + 2;
	}
      }

      return 0;

    case ambassador:
      j = 0;		//used to check if player has enough cards to discard

      if (choice2 > 2 || choice2 < 0)
	{
	  return -1;
	}

      if (choice1 == handPos)
	{
	  return -1;
	}

      for (i = 0; i < state->handCount[currentPlayer]; i++)
	{
	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
	    {
	      j++;
	    }
	}
      if (j < choice2)
	{
	  return -1;
	}

      if (DEBUG)
	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);

      //increase supply count for choosen card by amount being discarded
      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;

      //each other player gains a copy of revealed card
      for (i = 0; i < state->numPlayers; i++)
	{
	  if (i != currentPlayer)
	    {
	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
	    }
	}

      //discard played card from hand
      discardCard(handPos, currentPlayer, state, 0);

      //trash copies of cards returned to supply
      for (j = 0; j < choice2; j++)
	{
	  for (i = 0; i < state->handCount[currentPlayer]; i++)
	    {
	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
		{
		  discardCard(i, currentPlayer, state, 1);
		  break;
		}
	    }
	}

      return 0;

    case cutpurse:

      updateCoins(currentPlayer, state, 2);
      for (i = 0; i < state->numPlayers; i++)
	{
	  if (i != currentPlayer)
	    {
	      for (j = 0; j < state->handCount[i]; j++)
		{
		  if (state->hand[i][j] == copper)
		    {
		      discardCard(j, i, state, 0);
		      break;
		    }
		  if (j == state->handCount[i])
		    {
		      for (k = 0; k < state->handCount[i]; k++)
			{
			  if (DEBUG)
			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
			}
		      break;
		    }
		}

	    }

	}

      //discard played card from hand
      discardCard(handPos, currentPlayer, state, 0);

      return 0;


    case embargo:
      //+2 Coins
      state->coins = state->coins + 2;

      //see if selected pile is in play
      if ( state->supplyCount[choice1] == -1 )
	{
	  return -1;
	}

      //add embargo token to selected supply pile
      state->embargoTokens[choice1]++;

      //trash card
      discardCard(handPos, currentPlayer, state, 1);
      return 0;

    case outpost:
      //set outpost flag
      state->outpostPlayed++;

      //discard card
      discardCard(handPos, currentPlayer, state, 0);
      return 0;

    case salvager:
      //+1 buy
      state->numBuys++;

      if (choice1)
	{
	  //gain coins equal to trashed card
	  state->coins = state->coins + getCost( handCard(choice1, state) );
	  //trash card
	  discardCard(choice1, currentPlayer, state, 1);
	}

      //discard card
      discardCard(handPos, currentPlayer, state, 0);
      return 0;

    case sea_hag:
      for (i = 0; i < state->numPlayers; i++){
	if (i != currentPlayer){
	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
	  state->discardCount[i]++;
	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
	}
      }
      return 0;

    case treasure_map:
      //search hand for another treasure_map
      index = -1;
      for (i = 0; i < state->handCount[currentPlayer]; i++)
	{
	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
	    {
	      index = i;
	      break;
	    }
	}
      if (index > -1)
	{
	  //trash both treasure cards
	  discardCard(handPos, currentPlayer, state, 1);
	  discardCard(index, currentPlayer, state, 1);

	  //gain 4 Gold cards
	  for (i = 0; i < 4; i++)
	    {
	      gainCard(gold, state, 1, currentPlayer);
	    }

	  //return success
	  return 1;
	}

      //no second treasure_map found in hand
      return -1;
    }

  return -1;
}

int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
{

  //if card is not trashed, added to Played pile
  if (trashFlag < 1)
    {
      //add card to played pile
      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
      state->playedCardCount++;
    }

  //set played card to -1
  state->hand[currentPlayer][handPos] = -1;

  //remove card from player's hand
  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
    {
      //reduce number of cards in hand
      state->handCount[currentPlayer]--;
    }
  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
    {
      //reduce number of cards in hand
      state->handCount[currentPlayer]--;
    }
  else
    {
      //replace discarded card with last card in hand
      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
      //set last card to -1
      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
      //reduce number of cards in hand
      state->handCount[currentPlayer]--;
    }

  return 0;
}

int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
{
  //Note: supplyPos is enum of choosen card

  //check if supply pile is empty (0) or card is not used in game (-1)
  if ( supplyCount(supplyPos, state) < 1 )
    {
      return -1;
    }

  //added card for [whoseTurn] current player:
  // toFlag = 0 : add to discard
  // toFlag = 1 : add to deck
  // toFlag = 2 : add to hand

  if (toFlag == 1)
    {
      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
      state->deckCount[player]++;
    }
  else if (toFlag == 2)
    {
      state->hand[ player ][ state->handCount[player] ] = supplyPos;
      state->handCount[player]++;
    }
  else
    {
      state->discard[player][ state->discardCount[player] ] = supplyPos;
      state->discardCount[player]++;
    }

  //decrease number in supply pile
  state->supplyCount[supplyPos]--;

  return 0;
}

int updateCoins(int player, struct gameState *state, int bonus)
{
  int i;

  //reset coin count
  state->coins = 0;

  //add coins for each Treasure card in player's hand
  for (i = 0; i < state->handCount[player]; i++)
    {
      if (state->hand[player][i] == copper)
	{
	  state->coins += 1;
	}
      else if (state->hand[player][i] == silver)
	{
	  state->coins += 2;
	}
      else if (state->hand[player][i] == gold)
	{
	  state->coins += 3;
	}
    }

  //add bonus
  state->coins += bonus;

  return 0;
}


//end of dominion.c

File 'dominion.c'
Lines executed:29.74% of 575
Branches executed:31.48% of 413
Taken at least once:22.03% of 413
Calls executed:19.78% of 91
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:8
        -:    0:Programs:8
        -:    1:// Assignment 2, CS362-400-W16
        -:    2:// Andrew M. Calhoun
        -:    3:// calhouna@oregonstate.edu
        -:    4:// Due Date: 1/17/2016
        -:    5:
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:#include "rngs.h"
        -:    9:#include <stdio.h>
        -:   10:#include <math.h>
        -:   11:#include <stdlib.h>
        -:   12:
        -:   13:
        -:   14:
function compare called 248 returned 100% blocks executed 83%
      248:   15:int compare(const void* a, const void* b) {
      248:   16:  if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   17:    return 1;
      248:   18:  if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
       66:   19:    return -1;
      182:   20:  return 0;
        -:   21:}
        -:   22:
function newGame called 0 returned 0% blocks executed 0%
    #####:   23:struct gameState* newGame() {
    #####:   24:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   25:  return g;
        -:   26:}
        -:   27:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   28:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   29:		  int k8, int k9, int k10) {
    #####:   30:  int* k = malloc(10 * sizeof(int));
    #####:   31:  k[0] = k1;
    #####:   32:  k[1] = k2;
    #####:   33:  k[2] = k3;
    #####:   34:  k[3] = k4;
    #####:   35:  k[4] = k5;
    #####:   36:  k[5] = k6;
    #####:   37:  k[6] = k7;
    #####:   38:  k[7] = k8;
    #####:   39:  k[8] = k9;
    #####:   40:  k[9] = k10;
    #####:   41:  return k;
        -:   42:}
        -:   43:
function initializeGame called 8 returned 100% blocks executed 88%
        8:   44:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   45:		   struct gameState *state) {
        -:   46:
        -:   47:  int i;
        -:   48:  int j;
        -:   49:  int it;
        -:   50:  //set up random number generator
        8:   51:  SelectStream(1);
call    0 returned 100%
        8:   52:  PutSeed((long)randomSeed);
call    0 returned 100%
        -:   53:
        -:   54:  //check number of players
        8:   55:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   56:    {
    #####:   57:      return -1;
        -:   58:    }
        -:   59:
        -:   60:  //set number of players
        8:   61:  state->numPlayers = numPlayers;
        -:   62:
        -:   63:  //check selected kingdom cards are different
       88:   64:  for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   65:    {
      880:   66:      for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   67:        {
      800:   68:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   69:	    {
    #####:   70:	      return -1;
        -:   71:	    }
        -:   72:        }
        -:   73:    }
        -:   74:
        -:   75:
        -:   76:  //initialize supply
        -:   77:  ///////////////////////////////
        -:   78:
        -:   79:  //set number of Curse cards
        8:   80:  if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   81:    {
        8:   82:      state->supplyCount[curse] = 10;
        -:   83:    }
    #####:   84:  else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   85:    {
    #####:   86:      state->supplyCount[curse] = 20;
        -:   87:    }
        -:   88:  else
        -:   89:    {
    #####:   90:      state->supplyCount[curse] = 30;
        -:   91:    }
        -:   92:
        -:   93:  //set number of Victory cards
        8:   94:  if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   95:    {
        8:   96:      state->supplyCount[estate] = 8;
        8:   97:      state->supplyCount[duchy] = 8;
        8:   98:      state->supplyCount[province] = 8;
        -:   99:    }
        -:  100:  else
        -:  101:    {
    #####:  102:      state->supplyCount[estate] = 12;
    #####:  103:      state->supplyCount[duchy] = 12;
    #####:  104:      state->supplyCount[province] = 12;
        -:  105:    }
        -:  106:
        -:  107:  //set number of Treasure cards
        8:  108:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        8:  109:  state->supplyCount[silver] = 40;
        8:  110:  state->supplyCount[gold] = 30;
        -:  111:
        -:  112:  //set number of Kingdom cards
      168:  113:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  114:    {
     1320:  115:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  116:	{
     1240:  117:	  if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  118:	    {
        -:  119:	      //check if card is a 'Victory' Kingdom card
       94:  120:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 8% (fallthrough)
branch  3 taken 92%
        -:  121:		{
       14:  122:		  if (numPlayers == 2){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       14:  123:		    state->supplyCount[i] = 8;
        -:  124:		  }
    #####:  125:		  else{ state->supplyCount[i] = 12; }
        -:  126:		}
        -:  127:	      else
        -:  128:		{
       66:  129:		  state->supplyCount[i] = 10;
        -:  130:		}
       80:  131:	      break;
        -:  132:	    }
        -:  133:	  else    //card is not in the set choosen for the game
        -:  134:	    {
     1160:  135:	      state->supplyCount[i] = -1;
        -:  136:	    }
        -:  137:	}
        -:  138:
        -:  139:    }
        -:  140:
        -:  141:  ////////////////////////
        -:  142:  //supply initialization complete
        -:  143:
        -:  144:  //set player decks
       24:  145:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  146:    {
       16:  147:      state->deckCount[i] = 0;
       64:  148:      for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  149:	{
       48:  150:	  state->deck[i][j] = estate;
       48:  151:	  state->deckCount[i]++;
        -:  152:	}
      128:  153:      for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  154:	{
      112:  155:	  state->deck[i][j] = copper;
      112:  156:	  state->deckCount[i]++;
        -:  157:	}
        -:  158:    }
        -:  159:
        -:  160:  //shuffle player decks
       24:  161:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  162:    {
       16:  163:      if ( shuffle(i, state) < 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  164:	{
    #####:  165:	  return -1;
        -:  166:	}
        -:  167:    }
        -:  168:
        -:  169:  //draw player hands
       24:  170:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  171:    {
        -:  172:      //initialize hand size to zero
       16:  173:      state->handCount[i] = 0;
       16:  174:      state->discardCount[i] = 0;
        -:  175:      //draw 5 cards
        -:  176:      // for (j = 0; j < 5; j++)
        -:  177:      //	{
        -:  178:      //	  drawCard(i, state);
        -:  179:      //	}
        -:  180:    }
        -:  181:
        -:  182:  //set embargo tokens to 0 for all supply piles
      224:  183:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  184:    {
      216:  185:      state->embargoTokens[i] = 0;
        -:  186:    }
        -:  187:
        -:  188:  //initialize first player's turn
        8:  189:  state->outpostPlayed = 0;
        8:  190:  state->phase = 0;
        8:  191:  state->numActions = 1;
        8:  192:  state->numBuys = 1;
        8:  193:  state->playedCardCount = 0;
        8:  194:  state->whoseTurn = 0;
        8:  195:  state->handCount[state->whoseTurn] = 0;
        -:  196:  //int it; move to top
        -:  197:
        -:  198:  //Moved draw cards to here, only drawing at the start of a turn
       48:  199:  for (it = 0; it < 5; it++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       40:  200:    drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  201:  }
        -:  202:
        8:  203:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  204:
        8:  205:  return 0;
        -:  206:}
        -:  207:
function shuffle called 33 returned 100% blocks executed 100%
       33:  208:int shuffle(int player, struct gameState *state) {
        -:  209:
        -:  210:
        -:  211:  int newDeck[MAX_DECK];
       33:  212:  int newDeckPos = 0;
        -:  213:  int card;
        -:  214:  int i;
        -:  215:
       33:  216:  if (state->deckCount[player] < 1)
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
       10:  217:    return -1;
       23:  218:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
call    0 returned 100%
        -:  219:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  220:
      220:  221:  while (state->deckCount[player] > 0) {
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
      174:  222:    card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
      174:  223:    newDeck[newDeckPos] = state->deck[player][card];
      174:  224:    newDeckPos++;
      578:  225:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 70%
branch  1 taken 30% (fallthrough)
      404:  226:      state->deck[player][i] = state->deck[player][i+1];
        -:  227:    }
      174:  228:    state->deckCount[player]--;
        -:  229:  }
      197:  230:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
      174:  231:    state->deck[player][i] = newDeck[i];
      174:  232:    state->deckCount[player]++;
        -:  233:  }
        -:  234:
       23:  235:  return 0;
        -:  236:}
        -:  237:
function playCard called 0 returned 0% blocks executed 0%
    #####:  238:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  239:{
        -:  240:  int card;
    #####:  241:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  242:
        -:  243:  //check if it is the right phase
    #####:  244:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  245:    {
    #####:  246:      return -1;
        -:  247:    }
        -:  248:
        -:  249:  //check if player has enough actions
    #####:  250:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  251:    {
    #####:  252:      return -1;
        -:  253:    }
        -:  254:
        -:  255:  //get card played
    #####:  256:  card = handCard(handPos, state);
call    0 never executed
        -:  257:
        -:  258:  //check if selected card is an action
    #####:  259:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  260:    {
    #####:  261:      return -1;
        -:  262:    }
        -:  263:
        -:  264:  //play card
    #####:  265:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  266:    {
    #####:  267:      return -1;
        -:  268:    }
        -:  269:
        -:  270:  //reduce number of actions
    #####:  271:  state->numActions--;
        -:  272:
        -:  273:  //update coins (Treasure cards may be added with card draws)
    #####:  274:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  275:
    #####:  276:  return 0;
        -:  277:}
        -:  278:
function buyCard called 106 returned 100% blocks executed 65%
      106:  279:int buyCard(int supplyPos, struct gameState *state) {
        -:  280:  int who;
      106:  281:  if (DEBUG){
        -:  282:    printf("Entering buyCard...\n");
        -:  283:  }
        -:  284:
        -:  285:  // I don't know what to do about the phase thing.
        -:  286:
      106:  287:  who = state->whoseTurn;
        -:  288:
      106:  289:  if (state->numBuys < 1){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  290:    if (DEBUG)
        -:  291:      printf("You do not have any buys left\n");
    #####:  292:    return -1;
      106:  293:  } else if (supplyCount(supplyPos, state) <1){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  294:    if (DEBUG)
        -:  295:      printf("There are not any of that type of card left\n");
    #####:  296:    return -1;
      106:  297:  } else if (state->coins < getCost(supplyPos)){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  298:    if (DEBUG)
        -:  299:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  300:    return -1;
        -:  301:  } else {
      106:  302:    state->phase=1;
        -:  303:    //state->supplyCount[supplyPos]--;
      106:  304:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 returned 100%
        -:  305:
      106:  306:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 returned 100%
      106:  307:    state->numBuys--;
      106:  308:    if (DEBUG)
        -:  309:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  310:  }
        -:  311:
        -:  312:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  313:  //state->discardCount[who]++;
        -:  314:
      106:  315:  return 0;
        -:  316:}
        -:  317:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  318:int numHandCards(struct gameState *state) {
    #####:  319:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  320:}
        -:  321:
function handCard called 0 returned 0% blocks executed 0%
    #####:  322:int handCard(int handPos, struct gameState *state) {
    #####:  323:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  324:  return state->hand[currentPlayer][handPos];
        -:  325:}
        -:  326:
function supplyCount called 380 returned 100% blocks executed 100%
      380:  327:int supplyCount(int card, struct gameState *state) {
      380:  328:  return state->supplyCount[card];
        -:  329:}
        -:  330:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  331:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  332:  int i;
    #####:  333:  int count = 0;
        -:  334:
    #####:  335:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  336:    {
    #####:  337:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  338:    }
        -:  339:
    #####:  340:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  341:    {
    #####:  342:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  343:    }
        -:  344:
    #####:  345:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  346:    {
    #####:  347:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  348:    }
        -:  349:
    #####:  350:  return count;
        -:  351:}
        -:  352:
function whoseTurn called 1 returned 100% blocks executed 100%
        1:  353:int whoseTurn(struct gameState *state) {
        1:  354:  return state->whoseTurn;
        -:  355:}
        -:  356:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  357:int endTurn(struct gameState *state) {
        -:  358:  int k;
        -:  359:  int i;
    #####:  360:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  361:
        -:  362:  //Discard hand
    #####:  363:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  364:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  365:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  366:  }
    #####:  367:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  368:
        -:  369:  //Code for determining the player
    #####:  370:  if (currentPlayer < (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  371:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  372:  }
        -:  373:  else{
    #####:  374:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  375:  }
        -:  376:
    #####:  377:  state->outpostPlayed = 0;
    #####:  378:  state->phase = 0;
    #####:  379:  state->numActions = 1;
    #####:  380:  state->coins = 0;
    #####:  381:  state->numBuys = 1;
    #####:  382:  state->playedCardCount = 0;
    #####:  383:  state->handCount[state->whoseTurn] = 0;
        -:  384:
        -:  385:  //int k; move to top
        -:  386:  //Next player draws hand
    #####:  387:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  388:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  389:  }
        -:  390:
        -:  391:  //Update money
    #####:  392:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  393:
    #####:  394:  return 0;
        -:  395:}
        -:  396:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  397:int isGameOver(struct gameState *state) {
        -:  398:  int i;
        -:  399:  int j;
        -:  400:
        -:  401:  //if stack of Province cards is empty, the game ends
    #####:  402:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      return 1;
        -:  405:    }
        -:  406:
        -:  407:  //if three supply pile are at 0, the game ends
    #####:  408:  j = 0;
    #####:  409:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  412:	{
    #####:  413:	  j++;
        -:  414:	}
        -:  415:    }
    #####:  416:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  417:    {
    #####:  418:      return 1;
        -:  419:    }
        -:  420:
    #####:  421:  return 0;
        -:  422:}
        -:  423:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  424:int scoreFor (int player, struct gameState *state) {
        -:  425:
        -:  426:  int i;
    #####:  427:  int score = 0;
        -:  428:  //score from hand
    #####:  429:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  430:    {
    #####:  431:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  432:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  433:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  434:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  435:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  437:    }
        -:  438:
        -:  439:  //score from discard
    #####:  440:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  441:    {
    #####:  442:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  443:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  444:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  445:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  446:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  448:    }
        -:  449:
        -:  450:  //score from deck
    #####:  451:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  452:    {
    #####:  453:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  454:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  455:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  456:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  457:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  458:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  459:    }
        -:  460:
    #####:  461:  return score;
        -:  462:}
        -:  463:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  464:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  465:  int i;
        -:  466:  int j;
        -:  467:  int highScore;
        -:  468:  int currentPlayer;
        -:  469:
        -:  470:  //get score for each player
    #####:  471:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  472:    {
        -:  473:      //set unused player scores to -9999
    #####:  474:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  475:	{
    #####:  476:	  players[i] = -9999;
        -:  477:	}
        -:  478:      else
        -:  479:	{
    #####:  480:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  481:	}
        -:  482:    }
        -:  483:
        -:  484:  //find highest score
    #####:  485:  j = 0;
    #####:  486:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  487:    {
    #####:  488:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  489:	{
    #####:  490:	  j = i;
        -:  491:	}
        -:  492:    }
    #####:  493:  highScore = players[j];
        -:  494:
        -:  495:  //add 1 to players who had less turns
    #####:  496:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  497:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  498:    {
    #####:  499:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  500:	{
    #####:  501:	  players[i]++;
        -:  502:	}
        -:  503:    }
        -:  504:
        -:  505:  //find new highest score
    #####:  506:  j = 0;
    #####:  507:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  508:    {
    #####:  509:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  510:	{
    #####:  511:	  j = i;
        -:  512:	}
        -:  513:    }
    #####:  514:  highScore = players[j];
        -:  515:
        -:  516:  //set winners in array to 1 and rest to 0
    #####:  517:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  518:    {
    #####:  519:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  520:	{
    #####:  521:	  players[i] = 1;
        -:  522:	}
        -:  523:      else
        -:  524:	{
    #####:  525:	  players[i] = 0;
        -:  526:	}
        -:  527:    }
        -:  528:
    #####:  529:  return 0;
        -:  530:}
        -:  531:
function drawCard called 69 returned 100% blocks executed 86%
       69:  532:int drawCard(int player, struct gameState *state)
        -:  533:{	int count;
        -:  534:  int deckCounter;
       69:  535:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        -:  536:
        -:  537:    //Step 1 Shuffle the discard pile back into a deck
        -:  538:    int i;
        -:  539:    //Move discard to deck
        5:  540:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  541:      state->deck[player][i] = state->discard[player][i];
    #####:  542:      state->discard[player][i] = -1;
        -:  543:    }
        -:  544:
        5:  545:    state->deckCount[player] = state->discardCount[player];
        5:  546:    state->discardCount[player] = 0;//Reset discard
        -:  547:
        -:  548:    //Shufffle the deck
        5:  549:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  550:
        5:  551:    if (DEBUG){//Debug statements
        -:  552:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  553:    }
        -:  554:
        5:  555:    state->discardCount[player] = 0;
        -:  556:
        -:  557:    //Step 2 Draw Card
        5:  558:    count = state->handCount[player];//Get current player's hand count
        -:  559:
        5:  560:    if (DEBUG){//Debug statements
        -:  561:      printf("Current hand count: %d\n", count);
        -:  562:    }
        -:  563:
        5:  564:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  565:
        5:  566:    if (deckCounter == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        5:  567:      return -1;
        -:  568:
    #####:  569:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  570:    state->deckCount[player]--;
    #####:  571:    state->handCount[player]++;//Increment hand count
        -:  572:  }
        -:  573:
        -:  574:  else{
       64:  575:    int count = state->handCount[player];//Get current hand count for player
        -:  576:    int deckCounter;
       64:  577:    if (DEBUG){//Debug statements
        -:  578:      printf("Current hand count: %d\n", count);
        -:  579:    }
        -:  580:
       64:  581:    deckCounter = state->deckCount[player];//Create holder for the deck count
       64:  582:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       64:  583:    state->deckCount[player]--;
       64:  584:    state->handCount[player]++;//Increment hand count
        -:  585:  }
        -:  586:
       64:  587:  return 0;
        -:  588:}
        -:  589:
        -:  590:// PLAY CARD FUNCTIONS ----------------------------------------------------------------------------------------------
        -:  591://
        -:  592:// PLAY ADVENTURER
        -:  593://
        -:  594:
function playAdventurer called 0 returned 0% blocks executed 0%
    #####:  595:int playAdventurer(struct gameState *state, int currentPlayer, int cardDrawn, int drawntreasure, int temphand[], int z)
        -:  596:{
        -:  597:
    #####:  598:      while(drawntreasure<2){
branch  0 never executed
branch  1 never executed
    #####:  599:	if (state->deckCount[currentPlayer] <=1){//if the deck is empty we need to shuffle discard and add to deck *** REFACTOR to <= will cause additional shuffling.
branch  0 never executed
branch  1 never executed
    #####:  600:	  shuffle(currentPlayer, state);
call    0 never executed
        -:  601:	}
    #####:  602:	drawCard(currentPlayer, state);
call    0 never executed
    #####:  603:	cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  604:	if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  605:	  drawntreasure+=2; // The adventurer should not make off with your treasure. Originally had this put as --, but it actually caused the game to freeze. Opted to give the player more coins. Changes seeded outcomes.
        -:  606:	else{
    #####:  607:	  temphand[z]=cardDrawn;
    #####:  608:	  state->handCount[currentPlayer]++; //this should just remove the top card (the most recently drawn one).
    #####:  609:	  z++;
        -:  610:	}
        -:  611:      }
    #####:  612:      while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####:  613:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  614:	z=z-1;
        -:  615:      }
    #####:  616:      return 0;
        -:  617:}
        -:  618:
        -:  619://---------------------
        -:  620:// PLAY COUNCIL HALL
        -:  621://---------------------
function playCouncRoom called 0 returned 0% blocks executed 0%
    #####:  622:int playCouncRoom(struct gameState *state, int currentPlayer, int handPos)
        -:  623:{
        -:  624:    int i; // Needed to be declared under C99 standards, otherwise program breaks.
        -:  625:
        -:  626:    //+4 Cards ** REFACTORED TO 3 because of introduced bug.
    #####:  627:    for (i = 0; i < 4; ++i)
branch  0 never executed
branch  1 never executed
        -:  628:	{
    #####:  629:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  630:	}
        -:  631:
        -:  632:      //+1 Buy
    #####:  633:      state->numBuys++;
        -:  634:
        -:  635:      //Each other player draws a card
    #####:  636:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  637:	{
    #####:  638:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  639:	    {
    #####:  640:	      drawCard(i, state);
call    0 never executed
        -:  641:	    }
        -:  642:	}
        -:  643:
        -:  644:      //put played card in played card pile
    #####:  645:    discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  646:
    #####:  647:    return 0;
        -:  648:}
        -:  649:
        -:  650://-------------------------------
        -:  651:// PLAY MINION
        -:  652://-------------------------------
        -:  653:
function playMinion called 2 returned 100% blocks executed 78%
        2:  654:int playMinion(struct gameState *state, int choice1, int choice2, int currentPlayer, int handPos)
        -:  655:{
        -:  656:
        -:  657:    int i, j;
        -:  658:
        -:  659:
        -:  660:      //+1 action
        2:  661:      state->numActions--;
        -:  662:
        -:  663:      //discard card from hand
        2:  664:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  665:
        2:  666:      if (choice1)		//+2 coins *** REFACTORED: -2 coins.
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  667:	{
        1:  668:	  state->coins = state->coins - 2;
        -:  669:	}
        -:  670:
        1:  671:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  672:	{
        -:  673:
        -:  674://	  //discard hand ** COMMENTED OUT FOR REFACTORING
        -:  675://	  while(numHandCards(state) > 0)
        -:  676://	    {
        -:  677://	      discardCard(handPos, currentPlayer, state, 0);
        -:  678://	    }
        -:  679:
        -:  680:	  //draw 4 *** REFACTORED TO DRAW 3
        4:  681:	  for (i = 0; i < 3; i++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  682:	    {
        3:  683:	      drawCard(currentPlayer, state);
call    0 returned 100%
        -:  684:	    }
        -:  685:
        -:  686:	  //other players discard hand and redraw if hand size > 4 *** REFACTOR: They not only get to keep their cards, they get 3 MORE!
        3:  687:	  for (i = 0; i < state->numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  688:	    {
        2:  689:	      if (i != currentPlayer)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  690:		{
        1:  691:		  if ( state->handCount[i] > 4 )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  692:		    {
        -:  693:		    //  //discard hand
        -:  694:		    //  while( state->handCount[i] > 0 )
        -:  695:			// {
        -:  696:			//  discardCard(handPos, i, state, 0);
        -:  697:			// }
        -:  698:
        -:  699:		      //draw 4 ** REFACTOR: 3
    #####:  700:		      for (j = 0; j < 3; j++)
branch  0 never executed
branch  1 never executed
        -:  701:			{
    #####:  702:			  drawCard(i, state);
call    0 never executed
        -:  703:			}
        -:  704:		    }
        -:  705:		}
        -:  706:	    }
        -:  707:
        -:  708:	}
        2:  709:      return 0;
        -:  710:
        -:  711:}
        -:  712:
        -:  713://-------------------------------
        -:  714:// PLAY SMITHY
        -:  715://-------------------------------
        -:  716:
function playSmithy called 1 returned 100% blocks executed 100%
        1:  717:int playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  718:{
        -:  719:
        -:  720:    int i;
        -:  721:
        -:  722://+3 Cards  *** REFACTOR changes i++ to ++i, breaks the intent of the card.
        4:  723:      for (i = 0; i < 3; ++i)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  724:	{
        3:  725:	  drawCard(currentPlayer, state);
call    0 returned 100%
        -:  726:	}
        -:  727:      //discard card from hand
        1:  728:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        1:  729:      return 0;
        -:  730:}
        -:  731:
        -:  732:
        -:  733://-------------------------------
        -:  734:// VILLAGE
        -:  735://-------------------------------
        -:  736:
function playVillage called 1 returned 100% blocks executed 100%
        1:  737:int playVillage(struct gameState *state, int currentPlayer, int handPos)
        -:  738:{
        -:  739:      //+1 Card
        1:  740:      drawCard(currentPlayer, state);
call    0 returned 100%
        -:  741:
        -:  742:      //+2 Actions
        1:  743:      state->numActions = state->numActions + 2;
        -:  744:
        -:  745:      //discard played card from hand
        -:  746:      // discardCard(handPos, currentPlayer, state, 0);
        1:  747:      return 0;
        -:  748:
        -:  749:}
        -:  750:
        -:  751://---------------------------------
        -:  752:
function getCost called 424 returned 100% blocks executed 37%
      424:  753:int getCost(int cardNumber)
        -:  754:{
      424:  755:  switch( cardNumber )
branch  0 taken 9%
branch  1 taken 8%
branch  2 taken 8%
branch  3 taken 8%
branch  4 taken 11%
branch  5 taken 24%
branch  6 taken 14%
branch  7 taken 9%
branch  8 taken 9%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
branch 21 taken 0%
branch 22 taken 0%
branch 23 taken 0%
branch 24 taken 0%
branch 25 taken 0%
branch 26 taken 0%
branch 27 taken 0%
        -:  756:    {
        -:  757:    case curse:
       40:  758:      return 0;
        -:  759:    case estate:
       32:  760:      return 2;
        -:  761:    case duchy:
       32:  762:      return 5;
        -:  763:    case province:
       32:  764:      return 8;
        -:  765:    case copper:
       48:  766:      return 0;
        -:  767:    case silver:
      100:  768:      return 3;
        -:  769:    case gold:
       60:  770:      return 6;
        -:  771:    case adventurer:
       40:  772:      return 6;
        -:  773:    case council_room:
       40:  774:      return 5;
        -:  775:    case feast:
    #####:  776:      return 4;
        -:  777:    case gardens:
    #####:  778:      return 4;
        -:  779:    case mine:
    #####:  780:      return 5;
        -:  781:    case remodel:
    #####:  782:      return 4;
        -:  783:    case smithy:
    #####:  784:      return 4;
        -:  785:    case village:
    #####:  786:      return 3;
        -:  787:    case baron:
    #####:  788:      return 4;
        -:  789:    case great_hall:
    #####:  790:      return 3;
        -:  791:    case minion:
    #####:  792:      return 5;
        -:  793:    case steward:
    #####:  794:      return 3;
        -:  795:    case tribute:
    #####:  796:      return 5;
        -:  797:    case ambassador:
    #####:  798:      return 3;
        -:  799:    case cutpurse:
    #####:  800:      return 4;
        -:  801:    case embargo:
    #####:  802:      return 2;
        -:  803:    case outpost:
    #####:  804:      return 5;
        -:  805:    case salvager:
    #####:  806:      return 4;
        -:  807:    case sea_hag:
    #####:  808:      return 4;
        -:  809:    case treasure_map:
    #####:  810:      return 4;
        -:  811:    }
        -:  812:
    #####:  813:  return -1;
        -:  814:}
        -:  815:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  816:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  817:{
        -:  818:  int i;
        -:  819:  int j;
        -:  820:  int k;
        -:  821:  int x;
        -:  822:  int index;
    #####:  823:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  824:  int nextPlayer = currentPlayer + 1;
        -:  825:
    #####:  826:  int tributeRevealedCards[2] = {-1, -1};
        -:  827:  int temphand[MAX_HAND];// moved above the if statement
    #####:  828:  int drawntreasure=0;
        -:  829:  int cardDrawn;
    #####:  830:  int z = 0;// this is the counter for the temp hand
    #####:  831:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  832:    nextPlayer = 0;
        -:  833:  }
        -:  834:
        -:  835:
    #####:  836:switch(card)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  837:{
        -:  838://------------------------------------------------------------------------------
        -:  839:// Refactored cards/card function calls.
        -:  840:
        -:  841://----------------------------
        -:  842:// ADVENTURER
        -:  843:    case adventurer:
    #####:  844:        playAdventurer(state, currentPlayer, cardDrawn, drawntreasure, temphand, z);
call    0 never executed
    #####:  845:        break;
        -:  846://----------------------------
        -:  847:
        -:  848:
        -:  849://--------------------------------
        -:  850:// COUNCIL ROOM
        -:  851:    case council_room:
    #####:  852:        playCouncRoom(state, currentPlayer, handPos);
call    0 never executed
    #####:  853:        break;
        -:  854://---------------------------------
        -:  855:
        -:  856://---------------------------
        -:  857:// MINION
        -:  858://---------------------------
        -:  859:
        -:  860:    case minion:
    #####:  861:        playMinion(state, choice1, choice2, currentPlayer, handPos);
call    0 never executed
    #####:  862:        break;
        -:  863://--------------------------------
        -:  864:
        -:  865://-------------------------
        -:  866:// SMITHY
        -:  867://-------------------------
        -:  868:
        -:  869:case smithy:
    #####:  870:      playSmithy(state, currentPlayer, handPos);
call    0 never executed
    #####:  871:      break;
        -:  872:
        -:  873://-------------------------
        -:  874:
        -:  875://-------------------------
        -:  876:// VILLAGE
        -:  877://-------------------------
        -:  878:
        -:  879:case village:
    #####:  880:    playVillage(state, currentPlayer, handPos);
call    0 never executed
    #####:  881:    break;
        -:  882:
        -:  883://-------------------------
        -:  884:    case feast:
        -:  885:      //gain card with cost up to 5
        -:  886:      //Backup hand
    #####:  887:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  888:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  889:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  890:      }
        -:  891:      //Backup hand
        -:  892:
        -:  893:      //Update Coins for Buy
    #####:  894:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  895:      x = 1;//Condition to loop on
    #####:  896:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  897:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  898:	  if (DEBUG)
        -:  899:	    printf("None of that card left, sorry!\n");
        -:  900:
    #####:  901:	  if (DEBUG){
        -:  902:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  903:	  }
        -:  904:	}
    #####:  905:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  906:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  907:
    #####:  908:	  if (DEBUG){
        -:  909:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  910:	  }
        -:  911:	}
        -:  912:	else{
        -:  913:
    #####:  914:	  if (DEBUG){
        -:  915:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  916:	  }
        -:  917:
    #####:  918:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  919:	  x = 0;//No more buying cards
        -:  920:
    #####:  921:	  if (DEBUG){
        -:  922:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  923:	  }
        -:  924:
        -:  925:	}
        -:  926:      }
        -:  927:
        -:  928:      //Reset Hand
    #####:  929:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  930:	state->hand[currentPlayer][i] = temphand[i];
    #####:  931:	temphand[i] = -1;
        -:  932:      }
        -:  933:      //Reset Hand
        -:  934:
    #####:  935:      return 0;
        -:  936:
        -:  937:    case gardens:
    #####:  938:      return -1;
        -:  939:
        -:  940:    case mine:
    #####:  941:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  942:
    #####:  943:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  944:	{
    #####:  945:	  return -1;
        -:  946:	}
        -:  947:
    #####:  948:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  949:	{
    #####:  950:	  return -1;
        -:  951:	}
        -:  952:
    #####:  953:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  954:	{
    #####:  955:	  return -1;
        -:  956:	}
        -:  957:
    #####:  958:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  959:
        -:  960:      //discard card from hand
    #####:  961:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  962:
        -:  963:      //discard trashed card
    #####:  964:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  965:	{
    #####:  966:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  967:	    {
    #####:  968:	      discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  969:	      break;
        -:  970:	    }
        -:  971:	}
        -:  972:
    #####:  973:      return 0;
        -:  974:
        -:  975:    case remodel:
    #####:  976:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  977:
    #####:  978:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  979:	{
    #####:  980:	  return -1;
        -:  981:	}
        -:  982:
    #####:  983:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  984:
        -:  985:      //discard card from hand
    #####:  986:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  987:
        -:  988:      //discard trashed card
    #####:  989:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  990:	{
    #####:  991:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  992:	    {
    #####:  993:	      discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  994:	      break;
        -:  995:	    }
        -:  996:	}
        -:  997:
        -:  998:
    #####:  999:      return 0;
        -: 1000:
        -: 1001: case baron:
    #####: 1002:      state->numBuys++;//Increase buys by 1!
    #####: 1003:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####: 1004:	int p = 0;//Iterator for hand!
    #####: 1005:	int card_not_discarded = 1;//Flag for discard set!
    #####: 1006:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####: 1007:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####: 1008:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####: 1009:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####: 1010:	    state->discardCount[currentPlayer]++;
    #####: 1011:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####: 1012:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -: 1013:	    }
    #####: 1014:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####: 1015:	    state->handCount[currentPlayer]--;
    #####: 1016:	    card_not_discarded = 0;//Exit the loop
        -: 1017:	  }
    #####: 1018:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
    #####: 1019:	    if(DEBUG) {
        -: 1020:	      printf("No estate cards in your hand, invalid choice\n");
        -: 1021:	      printf("Must gain an estate if there are any\n");
        -: 1022:	    }
    #####: 1023:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1024:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####: 1025:	      state->supplyCount[estate]--;//Decrement estates
    #####: 1026:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1027:		isGameOver(state);
call    0 never executed
        -: 1028:	      }
        -: 1029:	    }
    #####: 1030:	    card_not_discarded = 0;//Exit the loop
        -: 1031:	  }
        -: 1032:
        -: 1033:	  else{
    #####: 1034:	    p++;//Next card
        -: 1035:	  }
        -: 1036:	}
        -: 1037:      }
        -: 1038:
        -: 1039:      else{
    #####: 1040:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1041:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####: 1042:	  state->supplyCount[estate]--;//Decrement Estates
    #####: 1043:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1044:	    isGameOver(state);
call    0 never executed
        -: 1045:	  }
        -: 1046:	}
        -: 1047:      }
        -: 1048:
        -: 1049:
    #####: 1050:      return 0;
        -: 1051:
        -: 1052:
        -: 1053:
        -: 1054:    case great_hall:
        -: 1055:      //+1 Card
    #####: 1056:      drawCard(currentPlayer, state);
call    0 never executed
        -: 1057:
        -: 1058:      //+1 Actions
    #####: 1059:      state->numActions++;
        -: 1060:
        -: 1061:      //discard card from hand
    #####: 1062:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1063:      return 0;
        -: 1064:
        -: 1065:    case steward:
    #####: 1066:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1067:	{
        -: 1068:	  //+2 cards
    #####: 1069:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1070:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1071:	}
    #####: 1072:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1073:	{
        -: 1074:	  //+2 coins
    #####: 1075:	  state->coins = state->coins + 2;
        -: 1076:	}
        -: 1077:      else
        -: 1078:	{
        -: 1079:	  //trash 2 cards in hand
    #####: 1080:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1081:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1082:	}
        -: 1083:
        -: 1084:      //discard card from hand
    #####: 1085:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1086:      return 0;
        -: 1087:
        -: 1088:    case tribute:
    #####: 1089:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1090:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1091:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1092:	  state->deckCount[nextPlayer]--;
        -: 1093:	}
    #####: 1094:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1095:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1096:	  state->discardCount[nextPlayer]--;
        -: 1097:	}
        -: 1098:	else{
        -: 1099:	  //No Card to Reveal
    #####: 1100:	  if (DEBUG){
        -: 1101:	    printf("No cards to reveal\n");
        -: 1102:	  }
        -: 1103:	}
        -: 1104:      }
        -: 1105:
        -: 1106:      else{
    #####: 1107:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1108:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1109:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1110:	    state->deckCount[nextPlayer]++;
    #####: 1111:	    state->discard[nextPlayer][i] = -1;
    #####: 1112:	    state->discardCount[nextPlayer]--;
        -: 1113:	  }
        -: 1114:
    #####: 1115:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1116:	}
    #####: 1117:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1118:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1119:	state->deckCount[nextPlayer]--;
    #####: 1120:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1121:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1122:	state->deckCount[nextPlayer]--;
        -: 1123:      }
        -: 1124:
    #####: 1125:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one
branch  0 never executed
branch  1 never executed
    #####: 1126:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1127:	state->playedCardCount++;
    #####: 1128:	tributeRevealedCards[1] = -1;
        -: 1129:      }
        -: 1130:
    #####: 1131:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1132:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1133:	  state->coins += 2;
        -: 1134:	}
        -: 1135:
    #####: 1136:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1137:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1138:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1139:	}
        -: 1140:	else{//Action Card
    #####: 1141:	  state->numActions = state->numActions + 2;
        -: 1142:	}
        -: 1143:      }
        -: 1144:
    #####: 1145:      return 0;
        -: 1146:
        -: 1147:    case ambassador:
    #####: 1148:      j = 0;		//used to check if player has enough cards to discard
        -: 1149:
    #####: 1150:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1151:	{
    #####: 1152:	  return -1;
        -: 1153:	}
        -: 1154:
    #####: 1155:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1156:	{
    #####: 1157:	  return -1;
        -: 1158:	}
        -: 1159:
    #####: 1160:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1161:	{
    #####: 1162:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1163:	    {
    #####: 1164:	      j++;
        -: 1165:	    }
        -: 1166:	}
    #####: 1167:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1168:	{
    #####: 1169:	  return -1;
        -: 1170:	}
        -: 1171:
    #####: 1172:      if (DEBUG)
        -: 1173:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1174:
        -: 1175:      //increase supply count for choosen card by amount being discarded
    #####: 1176:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1177:
        -: 1178:      //each other player gains a copy of revealed card
    #####: 1179:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1180:	{
    #####: 1181:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1182:	    {
    #####: 1183:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1184:	    }
        -: 1185:	}
        -: 1186:
        -: 1187:      //discard played card from hand
    #####: 1188:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1189:
        -: 1190:      //trash copies of cards returned to supply
    #####: 1191:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1192:	{
    #####: 1193:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1194:	    {
    #####: 1195:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1196:		{
    #####: 1197:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1198:		  break;
        -: 1199:		}
        -: 1200:	    }
        -: 1201:	}
        -: 1202:
    #####: 1203:      return 0;
        -: 1204:
        -: 1205:    case cutpurse:
        -: 1206:
    #####: 1207:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1208:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1209:	{
    #####: 1210:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1211:	    {
    #####: 1212:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1213:		{
    #####: 1214:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1215:		    {
    #####: 1216:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1217:		      break;
        -: 1218:		    }
    #####: 1219:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1220:		    {
    #####: 1221:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1222:			{
    #####: 1223:			  if (DEBUG)
        -: 1224:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1225:			}
    #####: 1226:		      break;
        -: 1227:		    }
        -: 1228:		}
        -: 1229:
        -: 1230:	    }
        -: 1231:
        -: 1232:	}
        -: 1233:
        -: 1234:      //discard played card from hand
    #####: 1235:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1236:
    #####: 1237:      return 0;
        -: 1238:
        -: 1239:
        -: 1240:    case embargo:
        -: 1241:      //+2 Coins
    #####: 1242:      state->coins = state->coins + 2;
        -: 1243:
        -: 1244:      //see if selected pile is in play
    #####: 1245:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1246:	{
    #####: 1247:	  return -1;
        -: 1248:	}
        -: 1249:
        -: 1250:      //add embargo token to selected supply pile
    #####: 1251:      state->embargoTokens[choice1]++;
        -: 1252:
        -: 1253:      //trash card
    #####: 1254:      discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1255:      return 0;
        -: 1256:
        -: 1257:    case outpost:
        -: 1258:      //set outpost flag
    #####: 1259:      state->outpostPlayed++;
        -: 1260:
        -: 1261:      //discard card
    #####: 1262:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1263:      return 0;
        -: 1264:
        -: 1265:    case salvager:
        -: 1266:      //+1 buy
    #####: 1267:      state->numBuys++;
        -: 1268:
    #####: 1269:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1270:	{
        -: 1271:	  //gain coins equal to trashed card
    #####: 1272:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1273:	  //trash card
    #####: 1274:	  discardCard(choice1, currentPlayer, state, 1);
call    0 never executed
        -: 1275:	}
        -: 1276:
        -: 1277:      //discard card
    #####: 1278:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1279:      return 0;
        -: 1280:
        -: 1281:    case sea_hag:
    #####: 1282:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1283:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1284:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1285:	  state->discardCount[i]++;
    #####: 1286:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1287:	}
        -: 1288:      }
    #####: 1289:      return 0;
        -: 1290:
        -: 1291:    case treasure_map:
        -: 1292:      //search hand for another treasure_map
    #####: 1293:      index = -1;
    #####: 1294:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1295:	{
    #####: 1296:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1297:	    {
    #####: 1298:	      index = i;
    #####: 1299:	      break;
        -: 1300:	    }
        -: 1301:	}
    #####: 1302:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1303:	{
        -: 1304:	  //trash both treasure cards
    #####: 1305:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1306:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1307:
        -: 1308:	  //gain 4 Gold cards
    #####: 1309:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1310:	    {
    #####: 1311:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1312:	    }
        -: 1313:
        -: 1314:	  //return success
    #####: 1315:	  return 1;
        -: 1316:	}
        -: 1317:
        -: 1318:      //no second treasure_map found in hand
    #####: 1319:      return -1;
        -: 1320:    }
        -: 1321:
    #####: 1322:  return -1;
        -: 1323:}
        -: 1324:
function discardCard called 6 returned 100% blocks executed 88%
        6: 1325:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1326:{
        -: 1327:
        -: 1328:  //if card is not trashed, added to Played pile
        6: 1329:  if (trashFlag < 1)
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
        -: 1330:    {
        -: 1331:      //add card to played pile
        5: 1332:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
        5: 1333:      state->playedCardCount++;
        -: 1334:    }
        -: 1335:
        -: 1336:  //set played card to -1
        6: 1337:  state->hand[currentPlayer][handPos] = -1;
        -: 1338:
        -: 1339:  //remove card from player's hand
        6: 1340:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1341:    {
        -: 1342:      //reduce number of cards in hand
    #####: 1343:      state->handCount[currentPlayer]--;
        -: 1344:    }
        6: 1345:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        -: 1346:    {
        -: 1347:      //reduce number of cards in hand
        1: 1348:      state->handCount[currentPlayer]--;
        -: 1349:    }
        -: 1350:  else
        -: 1351:    {
        -: 1352:      //replace discarded card with last card in hand
        5: 1353:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1354:      //set last card to -1
        5: 1355:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1356:      //reduce number of cards in hand
        5: 1357:      state->handCount[currentPlayer]--;
        -: 1358:    }
        -: 1359:
        6: 1360:  return 0;
        -: 1361:}
        -: 1362:
function gainCard called 106 returned 100% blocks executed 70%
      106: 1363:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1364:{
        -: 1365:  //Note: supplyPos is enum of choosen card
        -: 1366:
        -: 1367:  //check if supply pile is empty (0) or card is not used in game (-1)
      106: 1368:  if ( supplyCount(supplyPos, state) < 1 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 1369:    {
    #####: 1370:      return -1;
        -: 1371:    }
        -: 1372:
        -: 1373:  //added card for [whoseTurn] current player:
        -: 1374:  // toFlag = 0 : add to discard
        -: 1375:  // toFlag = 1 : add to deck
        -: 1376:  // toFlag = 2 : add to hand
        -: 1377:
      106: 1378:  if (toFlag == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1379:    {
    #####: 1380:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1381:      state->deckCount[player]++;
        -: 1382:    }
      106: 1383:  else if (toFlag == 2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1384:    {
    #####: 1385:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1386:      state->handCount[player]++;
        -: 1387:    }
        -: 1388:  else
        -: 1389:    {
      106: 1390:      state->discard[player][ state->discardCount[player] ] = supplyPos;
      106: 1391:      state->discardCount[player]++;
        -: 1392:    }
        -: 1393:
        -: 1394:  //decrease number in supply pile
      106: 1395:  state->supplyCount[supplyPos]--;
        -: 1396:
      106: 1397:  return 0;
        -: 1398:}
        -: 1399:
function updateCoins called 24 returned 100% blocks executed 90%
       24: 1400:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1401:{
        -: 1402:  int i;
        -: 1403:
        -: 1404:  //reset coin count
       24: 1405:  state->coins = 0;
        -: 1406:
        -: 1407:  //add coins for each Treasure card in player's hand
      112: 1408:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 79%
branch  1 taken 21% (fallthrough)
        -: 1409:    {
       88: 1410:      if (state->hand[player][i] == copper)
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
        -: 1411:	{
       50: 1412:	  state->coins += 1;
        -: 1413:	}
       38: 1414:      else if (state->hand[player][i] == silver)
branch  0 taken 63% (fallthrough)
branch  1 taken 37%
        -: 1415:	{
       24: 1416:	  state->coins += 2;
        -: 1417:	}
       14: 1418:      else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1419:	{
    #####: 1420:	  state->coins += 3;
        -: 1421:	}
        -: 1422:    }
        -: 1423:
        -: 1424:  //add bonus
       24: 1425:  state->coins += bonus;
        -: 1426:
       24: 1427:  return 0;
        -: 1428:}
        -: 1429:
        -: 1430:
        -: 1431://end of dominion.c
        -: 1432:
File 'unitTest1.c'
Lines executed:74.58% of 118
unitTest1.c:creating 'unitTest1.c.gcov'

        -:    0:Source:unitTest1.c
        -:    0:Graph:unitTest1.gcno
        -:    0:Data:unitTest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Andrew M. Calhoun
        -:    2:// UNIT TEST - ASSIGNMENT 3
        -:    3:// unitTest1.c
        -:    4:// Unit Test for updateCoin function.
        -:    5:
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:#include "rngs.h"
        -:    9:#include <string.h>
        -:   10:#include <stdio.h>
        -:   11:#include <assert.h>
        -:   12:#include <time.h>
        -:   13:#include <stdlib.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:
        -:   17:#define DEBUG 0
        -:   18:#define NOISY_TEST 1
        -:   19:
        -:   20:// updateCoins Code for Reference
        -:   21:
        -:   22:/* int updateCoins(int player, struct gameState *state, int bonus)
        -:   23:{
        -:   24:  int i;
        -:   25:
        -:   26:  //reset coin count
        -:   27:  state->coins = 0;
        -:   28:
        -:   29:  //add coins for each Treasure card in player's hand
        -:   30:  for (i = 0; i < state->handCount[player]; i++)
        -:   31:    {
        -:   32:      if (state->hand[player][i] == copper)
        -:   33:	{
        -:   34:	  state->coins += 1;
        -:   35:	}
        -:   36:      else if (state->hand[player][i] == silver)
        -:   37:	{
        -:   38:	  state->coins += 2;
        -:   39:	}
        -:   40:      else if (state->hand[player][i] == gold)
        -:   41:	{
        -:   42:	  state->coins += 3;
        -:   43:	}
        -:   44:    }
        -:   45:
        -:   46:  //add bonus
        -:   47:  state->coins += bonus;
        -:   48:
        -:   49:  return 0;
        -:   50:}
        -:   51:
        -:   52:*/
        -:   53:
        -:   54:// Unit Prototype
        -:   55:
        1:   56:int main()
        -:   57:{
        1:   58:    srand(time(NULL));
        -:   59:    int i, j; // counter variables
        -:   60:    int bonus;
        1:   61:    int testRun=0, testFailed=0, testPassed=0, randomTestFailed=0;// Test Counters
        1:   62:    struct gameState *state = malloc(sizeof(struct gameState));
        1:   63:    printf("STANDARDIZED TESTS:\nINITIALIZE GAME: 2 players... deck initialized.... state and memory allocated.\n");
        1:   64:    int k[10] = {adventurer, smithy, village, minion, council_room, feast, mine, remodel, baron, great_hall};
        1:   65:    initializeGame(2, k, 1, state);
        -:   66:
        1:   67:    bonus = rand() % 10;
        -:   68:    int goldBinary, goldHold;
        -:   69:
        -:   70:    int playerOneHand[10], playerTwoHand[10];
        -:   71:    memcpy(state->hand[0], playerOneHand, 0);
        -:   72:    memcpy(state->hand[0], playerTwoHand, 0);
        1:   73:    state->handCount[0] = 0;
        -:   74:
        1:   75:    printf("State Coins: %d\n", state->coins);
        -:   76:
        1:   77:    assert(state->coins == 4);
        -:   78:    assert(playerOneHand);
        -:   79:    assert(playerTwoHand);
        1:   80:    assert(bonus <= 10);
        -:   81:
        -:   82:    // No Bonus, Empty Hand.
        -:   83:
        -:   84:    // printf("Randomized Test Value: %d\n", randomTestFailed);
        -:   85:
        1:   86:    printf("Empty Hand, No Bonus Cash.\n");
        1:   87:    updateCoins(0, state, 0);
        1:   88:    if(state->coins == 0) {
        1:   89:        printf("Test #1 Passed.\n");
        1:   90:        testRun++;
        1:   91:        testPassed++;
        -:   92:    }
        -:   93:    else
        -:   94:    {
    #####:   95:        printf("Test #1 failed.\n Test found %d coins instead of 0\n.", state->coins);
    #####:   96:        testRun++;
    #####:   97:        testFailed++;
    #####:   98:        randomTestFailed = 1;
        -:   99:    }
        -:  100:
        1:  101:    printf("Empty hand, 10 coin bonus.\n");
        1:  102:    updateCoins(0, state, 10);
        1:  103:    if(state->coins==10)
        -:  104:    {
        1:  105:       printf("Test #2 Passed.\n");
        1:  106:       testRun++;
        1:  107:       testPassed++;
        -:  108:    }
        -:  109:    else
        -:  110:    {
    #####:  111:        printf("Test #2 failed.\n Test found %d coins instead of 10.\n", state->coins);
    #####:  112:        testRun++;
    #####:  113:        testFailed++;
    #####:  114:        randomTestFailed = 1;
        -:  115:    }
        -:  116:
        1:  117:    printf("Empty hand, randomized bonus.\n");
        1:  118:    updateCoins(0, state, bonus);
        1:  119:    if(state->coins==bonus)
        -:  120:    {
        1:  121:        printf("Test #3 Passed.\n");
        1:  122:        testRun++;
        1:  123:        testPassed++;
        -:  124:    }
        -:  125:    else
        -:  126:    {
    #####:  127:        printf("Test #3 failed.\n Test found %d instead of %d.\n", state->coins, bonus);
    #####:  128:        testRun++;
    #####:  129:        testFailed++;
    #####:  130:        randomTestFailed=1;
        -:  131:    }
        -:  132:
        1:  133:    printf("No coins, negative bonus.\n");
        1:  134:    updateCoins(0, state, -5);
        1:  135:    if(state->coins == -5)
        -:  136:    {
        1:  137:        printf("Test #4 Passed.\n");
        1:  138:        testRun++;
        1:  139:        testPassed++;
        -:  140:    }
        -:  141:    else
        -:  142:    {
    #####:  143:        printf("Test #4 Failed.\n");
    #####:  144:        testRun++;
    #####:  145:        testFailed++;
    #####:  146:        randomTestFailed=1;
        -:  147:    }
        -:  148:
        1:  149:    printf("Two Coppers, Two Silver, No Bonus.\n");
        1:  150:    playerOneHand[0] = copper;
        1:  151:    playerOneHand[1] = copper;
        1:  152:    playerOneHand[2] = silver;
        1:  153:    playerOneHand[3] = silver;
        1:  154:    memcpy(state->hand[0], playerOneHand, 4 * sizeof(int));
        1:  155:    state->handCount[0] = 4;
        -:  156:
        1:  157:    updateCoins(0, state, 0);
        1:  158:    if(state->coins == 6)
        -:  159:    {
        1:  160:        printf("Test #4 Passed!\n");
        1:  161:        testRun++;
        1:  162:        testPassed++;
        -:  163:    }
        -:  164:    else
        -:  165:    {
    #####:  166:        printf("Test #4 Failed.\n Test found %d instead of 6 coins.\n", state->coins);
    #####:  167:        testRun++;
    #####:  168:        testFailed++;
    #####:  169:        randomTestFailed=1;
        -:  170:
        -:  171:    }
        -:  172:
        1:  173:    printf("Same test, two bonus.\n");
        1:  174:    updateCoins(0, state, 2);
        1:  175:    if(state->coins == 8)
        -:  176:    {
        1:  177:        printf("Test #5 Passed!\n");
        1:  178:        testRun++;
        1:  179:        testPassed++;
        -:  180:    }
        -:  181:    else
        -:  182:    {
    #####:  183:        printf("Test #5 Failed.\n");
    #####:  184:        testRun++;
    #####:  185:        testFailed++;
    #####:  186:        randomTestFailed=1;
        -:  187:    }
        -:  188:
        -:  189:    // printf("Randomized Test Value: %d\n", randomTestFailed);
        -:  190:    // Reset the Number of Coins Held.
        -:  191:    // state->coins = 0;
        -:  192:
        1:  193:    printf("Fully Randomized Tests\n");
       11:  194:    for(i = 0; i < 10; i++)
        -:  195:    {
       10:  196:        state->coins = 0;
      110:  197:        for(j=0; j<10; j++)
        -:  198:        {
      100:  199:            goldBinary = rand() % 3;
      100:  200:            switch(goldBinary)
        -:  201:            {
        -:  202:                case 0:
       36:  203:                    playerOneHand[j] = copper;
       36:  204:                    break;
        -:  205:                case 1:
       32:  206:                    playerOneHand[j] = silver;
       32:  207:                    break;
        -:  208:                case 2:
       32:  209:                    playerOneHand[j] = gold;
        -:  210:                    break;
        -:  211:            }
        -:  212:        }
      110:  213:        for(j=0; j<10; j++)
        -:  214:        {
      100:  215:            if(state->hand[0][j] == copper)
        -:  216:            {
       20:  217:                state->coins += 1;
        -:  218:            }
      100:  219:            if(state->hand[0][j] == silver)
        -:  220:            {
       20:  221:                state->coins += 2;
        -:  222:            }
      100:  223:            if(state->hand[0][j] == gold)
        -:  224:            {
    #####:  225:                state->coins += 3;
        -:  226:            }
        -:  227:        }
        -:  228:
       10:  229:        goldHold = state->coins;
       10:  230:        bonus = rand() % 10;
       10:  231:        goldHold += bonus;
       10:  232:        updateCoins(0, state, bonus);
        -:  233:
       10:  234:        if(state->coins == goldHold)
        -:  235:        {
       10:  236:            printf("State Gold (Expected): %d\n", state->coins);
       10:  237:            printf("Player Gold (Result): %d\n", goldHold);
       10:  238:            printf("Randomized Test Passed.\n");
       10:  239:            testRun++;
       10:  240:            testPassed++;
        -:  241:        }
        -:  242:        else
        -:  243:        {
    #####:  244:            printf("Randomized Test Failed.\n");
    #####:  245:            testRun++;
    #####:  246:            testFailed++;
    #####:  247:            randomTestFailed=1;
        -:  248:           // break;  // if any randomized tests fail, break the loop..
        -:  249:        }
        -:  250:    }
        -:  251:
        -:  252:    // state->coins = 0;
        1:  253:    printf("Tests Run: %d\n", testRun);
        1:  254:    printf("Tests Passed: %d\n", testPassed);
        1:  255:    printf("Tests Failed: %d\n", testFailed);
        -:  256:
        -:  257:
        1:  258:    printf("Randomized Test Fail Value: %d\n", randomTestFailed);
        -:  259:
        -:  260:
        1:  261:    if(randomTestFailed == 0)
        -:  262:    {
        1:  263:        printf("All Random Tests Passed!\n\n");
        -:  264:    }
        -:  265:    else
        -:  266:    {
    #####:  267:        printf("One or more random tests failed.\n\n");
        -:  268:    }
        -:  269://    // 4000 Test Cases (20^2)
        -:  270://        for(i = 0; i < 4000; i++)
        -:  271://        {
        -:  272://            for(i = 0; i < sizeof(struct gameState); i++)
        -:  273://            {
        -:  274://                result = unitTest(state);
        -:  275://                if(result == 1) printf("FAIL!\n");
        -:  276://                else printf("PASS!\n");
        -:  277://            }
        -:  278://        }
        -:  279://
        1:  280:    return 0;
        -:  281:}
        -:  282:
        -:  283:
        -:  284:
File 'unitTest1.c'
Lines executed:74.58% of 118
Branches executed:100.00% of 36
Taken at least once:66.67% of 36
Calls executed:78.26% of 46
unitTest1.c:creating 'unitTest1.c.gcov'

        -:    0:Source:unitTest1.c
        -:    0:Graph:unitTest1.gcno
        -:    0:Data:unitTest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Andrew M. Calhoun
        -:    2:// UNIT TEST - ASSIGNMENT 3
        -:    3:// unitTest1.c
        -:    4:// Unit Test for updateCoin function.
        -:    5:
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:#include "rngs.h"
        -:    9:#include <string.h>
        -:   10:#include <stdio.h>
        -:   11:#include <assert.h>
        -:   12:#include <time.h>
        -:   13:#include <stdlib.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:
        -:   17:#define DEBUG 0
        -:   18:#define NOISY_TEST 1
        -:   19:
        -:   20:// updateCoins Code for Reference
        -:   21:
        -:   22:/* int updateCoins(int player, struct gameState *state, int bonus)
        -:   23:{
        -:   24:  int i;
        -:   25:
        -:   26:  //reset coin count
        -:   27:  state->coins = 0;
        -:   28:
        -:   29:  //add coins for each Treasure card in player's hand
        -:   30:  for (i = 0; i < state->handCount[player]; i++)
        -:   31:    {
        -:   32:      if (state->hand[player][i] == copper)
        -:   33:	{
        -:   34:	  state->coins += 1;
        -:   35:	}
        -:   36:      else if (state->hand[player][i] == silver)
        -:   37:	{
        -:   38:	  state->coins += 2;
        -:   39:	}
        -:   40:      else if (state->hand[player][i] == gold)
        -:   41:	{
        -:   42:	  state->coins += 3;
        -:   43:	}
        -:   44:    }
        -:   45:
        -:   46:  //add bonus
        -:   47:  state->coins += bonus;
        -:   48:
        -:   49:  return 0;
        -:   50:}
        -:   51:
        -:   52:*/
        -:   53:
        -:   54:// Unit Prototype
        -:   55:
function main called 1 returned 100% blocks executed 80%
        1:   56:int main()
        -:   57:{
        1:   58:    srand(time(NULL));
call    0 returned 100%
call    1 returned 100%
        -:   59:    int i, j; // counter variables
        -:   60:    int bonus;
        1:   61:    int testRun=0, testFailed=0, testPassed=0, randomTestFailed=0;// Test Counters
        1:   62:    struct gameState *state = malloc(sizeof(struct gameState));
        1:   63:    printf("STANDARDIZED TESTS:\nINITIALIZE GAME: 2 players... deck initialized.... state and memory allocated.\n");
call    0 returned 100%
        1:   64:    int k[10] = {adventurer, smithy, village, minion, council_room, feast, mine, remodel, baron, great_hall};
        1:   65:    initializeGame(2, k, 1, state);
call    0 returned 100%
        -:   66:
        1:   67:    bonus = rand() % 10;
call    0 returned 100%
        -:   68:    int goldBinary, goldHold;
        -:   69:
        -:   70:    int playerOneHand[10], playerTwoHand[10];
        -:   71:    memcpy(state->hand[0], playerOneHand, 0);
        -:   72:    memcpy(state->hand[0], playerTwoHand, 0);
        1:   73:    state->handCount[0] = 0;
        -:   74:
        1:   75:    printf("State Coins: %d\n", state->coins);
call    0 returned 100%
        -:   76:
        1:   77:    assert(state->coins == 4);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   78:    assert(playerOneHand);
        -:   79:    assert(playerTwoHand);
        1:   80:    assert(bonus <= 10);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   81:
        -:   82:    // No Bonus, Empty Hand.
        -:   83:
        -:   84:    // printf("Randomized Test Value: %d\n", randomTestFailed);
        -:   85:
        1:   86:    printf("Empty Hand, No Bonus Cash.\n");
call    0 returned 100%
        1:   87:    updateCoins(0, state, 0);
call    0 returned 100%
        1:   88:    if(state->coins == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   89:        printf("Test #1 Passed.\n");
call    0 returned 100%
        1:   90:        testRun++;
        1:   91:        testPassed++;
        -:   92:    }
        -:   93:    else
        -:   94:    {
    #####:   95:        printf("Test #1 failed.\n Test found %d coins instead of 0\n.", state->coins);
call    0 never executed
    #####:   96:        testRun++;
    #####:   97:        testFailed++;
    #####:   98:        randomTestFailed = 1;
        -:   99:    }
        -:  100:
        1:  101:    printf("Empty hand, 10 coin bonus.\n");
call    0 returned 100%
        1:  102:    updateCoins(0, state, 10);
call    0 returned 100%
        1:  103:    if(state->coins==10)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  104:    {
        1:  105:       printf("Test #2 Passed.\n");
call    0 returned 100%
        1:  106:       testRun++;
        1:  107:       testPassed++;
        -:  108:    }
        -:  109:    else
        -:  110:    {
    #####:  111:        printf("Test #2 failed.\n Test found %d coins instead of 10.\n", state->coins);
call    0 never executed
    #####:  112:        testRun++;
    #####:  113:        testFailed++;
    #####:  114:        randomTestFailed = 1;
        -:  115:    }
        -:  116:
        1:  117:    printf("Empty hand, randomized bonus.\n");
call    0 returned 100%
        1:  118:    updateCoins(0, state, bonus);
call    0 returned 100%
        1:  119:    if(state->coins==bonus)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  120:    {
        1:  121:        printf("Test #3 Passed.\n");
call    0 returned 100%
        1:  122:        testRun++;
        1:  123:        testPassed++;
        -:  124:    }
        -:  125:    else
        -:  126:    {
    #####:  127:        printf("Test #3 failed.\n Test found %d instead of %d.\n", state->coins, bonus);
call    0 never executed
    #####:  128:        testRun++;
    #####:  129:        testFailed++;
    #####:  130:        randomTestFailed=1;
        -:  131:    }
        -:  132:
        1:  133:    printf("No coins, negative bonus.\n");
call    0 returned 100%
        1:  134:    updateCoins(0, state, -5);
call    0 returned 100%
        1:  135:    if(state->coins == -5)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  136:    {
        1:  137:        printf("Test #4 Passed.\n");
call    0 returned 100%
        1:  138:        testRun++;
        1:  139:        testPassed++;
        -:  140:    }
        -:  141:    else
        -:  142:    {
    #####:  143:        printf("Test #4 Failed.\n");
call    0 never executed
    #####:  144:        testRun++;
    #####:  145:        testFailed++;
    #####:  146:        randomTestFailed=1;
        -:  147:    }
        -:  148:
        1:  149:    printf("Two Coppers, Two Silver, No Bonus.\n");
call    0 returned 100%
        1:  150:    playerOneHand[0] = copper;
        1:  151:    playerOneHand[1] = copper;
        1:  152:    playerOneHand[2] = silver;
        1:  153:    playerOneHand[3] = silver;
        1:  154:    memcpy(state->hand[0], playerOneHand, 4 * sizeof(int));
        1:  155:    state->handCount[0] = 4;
        -:  156:
        1:  157:    updateCoins(0, state, 0);
call    0 returned 100%
        1:  158:    if(state->coins == 6)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  159:    {
        1:  160:        printf("Test #4 Passed!\n");
call    0 returned 100%
        1:  161:        testRun++;
        1:  162:        testPassed++;
        -:  163:    }
        -:  164:    else
        -:  165:    {
    #####:  166:        printf("Test #4 Failed.\n Test found %d instead of 6 coins.\n", state->coins);
call    0 never executed
    #####:  167:        testRun++;
    #####:  168:        testFailed++;
    #####:  169:        randomTestFailed=1;
        -:  170:
        -:  171:    }
        -:  172:
        1:  173:    printf("Same test, two bonus.\n");
call    0 returned 100%
        1:  174:    updateCoins(0, state, 2);
call    0 returned 100%
        1:  175:    if(state->coins == 8)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  176:    {
        1:  177:        printf("Test #5 Passed!\n");
call    0 returned 100%
        1:  178:        testRun++;
        1:  179:        testPassed++;
        -:  180:    }
        -:  181:    else
        -:  182:    {
    #####:  183:        printf("Test #5 Failed.\n");
call    0 never executed
    #####:  184:        testRun++;
    #####:  185:        testFailed++;
    #####:  186:        randomTestFailed=1;
        -:  187:    }
        -:  188:
        -:  189:    // printf("Randomized Test Value: %d\n", randomTestFailed);
        -:  190:    // Reset the Number of Coins Held.
        -:  191:    // state->coins = 0;
        -:  192:
        1:  193:    printf("Fully Randomized Tests\n");
call    0 returned 100%
       11:  194:    for(i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:  195:    {
       10:  196:        state->coins = 0;
      110:  197:        for(j=0; j<10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:  198:        {
      100:  199:            goldBinary = rand() % 3;
call    0 returned 100%
      100:  200:            switch(goldBinary)
branch  0 taken 36%
branch  1 taken 32%
branch  2 taken 32%
branch  3 taken 0%
        -:  201:            {
        -:  202:                case 0:
       36:  203:                    playerOneHand[j] = copper;
       36:  204:                    break;
        -:  205:                case 1:
       32:  206:                    playerOneHand[j] = silver;
       32:  207:                    break;
        -:  208:                case 2:
       32:  209:                    playerOneHand[j] = gold;
        -:  210:                    break;
        -:  211:            }
        -:  212:        }
      110:  213:        for(j=0; j<10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:  214:        {
      100:  215:            if(state->hand[0][j] == copper)
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        -:  216:            {
       20:  217:                state->coins += 1;
        -:  218:            }
      100:  219:            if(state->hand[0][j] == silver)
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        -:  220:            {
       20:  221:                state->coins += 2;
        -:  222:            }
      100:  223:            if(state->hand[0][j] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  224:            {
    #####:  225:                state->coins += 3;
        -:  226:            }
        -:  227:        }
        -:  228:
       10:  229:        goldHold = state->coins;
       10:  230:        bonus = rand() % 10;
call    0 returned 100%
       10:  231:        goldHold += bonus;
       10:  232:        updateCoins(0, state, bonus);
call    0 returned 100%
        -:  233:
       10:  234:        if(state->coins == goldHold)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  235:        {
       10:  236:            printf("State Gold (Expected): %d\n", state->coins);
call    0 returned 100%
       10:  237:            printf("Player Gold (Result): %d\n", goldHold);
call    0 returned 100%
       10:  238:            printf("Randomized Test Passed.\n");
call    0 returned 100%
       10:  239:            testRun++;
       10:  240:            testPassed++;
        -:  241:        }
        -:  242:        else
        -:  243:        {
    #####:  244:            printf("Randomized Test Failed.\n");
call    0 never executed
    #####:  245:            testRun++;
    #####:  246:            testFailed++;
    #####:  247:            randomTestFailed=1;
        -:  248:           // break;  // if any randomized tests fail, break the loop..
        -:  249:        }
        -:  250:    }
        -:  251:
        -:  252:    // state->coins = 0;
        1:  253:    printf("Tests Run: %d\n", testRun);
call    0 returned 100%
        1:  254:    printf("Tests Passed: %d\n", testPassed);
call    0 returned 100%
        1:  255:    printf("Tests Failed: %d\n", testFailed);
call    0 returned 100%
        -:  256:
        -:  257:
        1:  258:    printf("Randomized Test Fail Value: %d\n", randomTestFailed);
call    0 returned 100%
        -:  259:
        -:  260:
        1:  261:    if(randomTestFailed == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  262:    {
        1:  263:        printf("All Random Tests Passed!\n\n");
call    0 returned 100%
        -:  264:    }
        -:  265:    else
        -:  266:    {
    #####:  267:        printf("One or more random tests failed.\n\n");
call    0 never executed
        -:  268:    }
        -:  269://    // 4000 Test Cases (20^2)
        -:  270://        for(i = 0; i < 4000; i++)
        -:  271://        {
        -:  272://            for(i = 0; i < sizeof(struct gameState); i++)
        -:  273://            {
        -:  274://                result = unitTest(state);
        -:  275://                if(result == 1) printf("FAIL!\n");
        -:  276://                else printf("PASS!\n");
        -:  277://            }
        -:  278://        }
        -:  279://
        1:  280:    return 0;
        -:  281:}
        -:  282:
        -:  283:
        -:  284:
File 'unitTest2.c'
Lines executed:95.92% of 49
unitTest2.c:creating 'unitTest2.c.gcov'

        -:    0:Source:unitTest2.c
        -:    0:Graph:unitTest2.gcno
        -:    0:Data:unitTest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Andrew M. Calhoun
        -:    2:// UNIT TEST - ASSIGNMENT 3
        -:    3:// unitTest2.c
        -:    4:// Unit Test for discardCard function.
        -:    5:
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:#include "rngs.h"
        -:    9:#include <string.h>
        -:   10:#include <stdio.h>
        -:   11:#include <assert.h>
        -:   12:#include <time.h>
        -:   13:#include <stdlib.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:
        -:   17:#define DEBUG 0
        -:   18:#define NOISY_TEST 0
        -:   19:
        -:   20:/* discardCard for Reference
        -:   21:
        -:   22:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -:   23:{
        -:   24:
        -:   25:  //if card is not trashed, added to Played pile
        -:   26:  if (trashFlag < 1)
        -:   27:    {
        -:   28:      //add card to played pile
        -:   29:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
        -:   30:      state->playedCardCount++;
        -:   31:    }
        -:   32:
        -:   33:  //set played card to -1
        -:   34:  state->hand[currentPlayer][handPos] = -1;
        -:   35:
        -:   36:  //remove card from player's hand
        -:   37:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -:   38:    {
        -:   39:      //reduce number of cards in hand
        -:   40:      state->handCount[currentPlayer]--;
        -:   41:    }
        -:   42:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -:   43:    {
        -:   44:      //reduce number of cards in hand
        -:   45:      state->handCount[currentPlayer]--;
        -:   46:    }
        -:   47:  else
        -:   48:    {
        -:   49:      //replace discarded card with last card in hand
        -:   50:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -:   51:      //set last card to -1
        -:   52:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -:   53:      //reduce number of cards in hand
        -:   54:      state->handCount[currentPlayer]--;
        -:   55:    }
        -:   56:
        -:   57:  return 0;
        -:   58:}
        -:   59:
        -:   60:*/
        -:   61:
        3:   62:int checkDiscardCard(int handPos, int currentPlayer, struct gameState *post, int trashFlag)
        -:   63:{
        -:   64:
        3:   65:    struct gameState *pre = malloc(sizeof(struct gameState));
        3:   66:    memcpy(pre, post, sizeof(struct gameState));
        -:   67:    int r;
        -:   68:
        3:   69:    r = discardCard(handPos, currentPlayer, post, trashFlag);
        -:   70:
        3:   71:    if(trashFlag != 1)
        -:   72:    {
        2:   73:        assert(post->playedCards[pre->playedCardCount] == pre->hand[currentPlayer][handPos]);
        2:   74:        assert(pre->playedCardCount + 1 == post->playedCardCount);
        -:   75:    }
        -:   76:
        3:   77:    assert(post->hand[currentPlayer][handPos] = -1);
        -:   78:
        3:   79:    if(handPos == (pre->handCount[currentPlayer] - 1))
        -:   80:    {
    #####:   81:        assert(pre->handCount[currentPlayer] - 1 == post->handCount[currentPlayer] );
        -:   82:    }
        3:   83:    else if (pre->handCount[currentPlayer] == 1)
        -:   84:    {
        1:   85:        assert(pre->handCount[currentPlayer] - 1 == post->handCount[currentPlayer]);
        -:   86:    }
        -:   87:    else
        -:   88:    {
        2:   89:        assert(pre->hand[currentPlayer][(pre->handCount[currentPlayer])] == post->hand[currentPlayer][ (post->handCount[currentPlayer] + 1 ) ] );
        2:   90:        assert(post->hand[currentPlayer][post->handCount[currentPlayer]] == -1);
        2:   91:        assert(pre->handCount[currentPlayer] - 1 == post->handCount[currentPlayer] );
        -:   92:    }
        -:   93:
        3:   94:    assert(r==0);
        3:   95:    free(pre);
        3:   96:    return 0;
        -:   97:
        -:   98:}
        -:   99:
        1:  100:int main()
        -:  101:{
        1:  102:    srand(time(NULL));
        1:  103:    struct gameState *state = malloc(sizeof(struct gameState));
        1:  104:    int player = 0, handPos, trash;
        1:  105:    int k[10] = {adventurer, smithy, great_hall, council_room, baron, minion, mine, village, ambassador, salvager};
        -:  106:
        1:  107:    int seed = rand() % 65535;
        -:  108:
        1:  109:    initializeGame(2, k, seed, state);
        -:  110:
        1:  111:    printf("Testing the Discard Card Function\n");
        -:  112:
        -:  113:    // for(i = 0; i < sizeof(state); i++)
        -:  114:        // printf("Failure Point 1\n");
        -:  115:       //  int handCountConst = floor(Random() * MAX_HAND);
        -:  116:        // p=0;
        1:  117:        handPos = rand() % 10;
        -:  118:
        1:  119:        state->deckCount[0] = 50;
        1:  120:        state->discardCount[0] = 10;
        1:  121:        state->handCount[0] = 8;
        1:  122:        state->discard[player][state->discardCount[player]] = 100;
        1:  123:        state->playedCardCount = rand() % 10;
        -:  124:        // printf("Failure Point 2\n");
        -:  125:
        1:  126:        if(handPos > 0)
        -:  127:        {
        1:  128:            state->playedCards[state->playedCardCount] = state->hand[0][handPos];
        -:  129:        }
        -:  130:        else
        -:  131:        {
    #####:  132:            state->playedCards[state->playedCardCount] = state->hand[0][handPos - 1];
        -:  133:        }
        -:  134:
        1:  135:        trash = 0;
        -:  136:
        1:  137:        checkDiscardCard(handPos, player, state, trash); // trash = 0 check.
        1:  138:        printf("All assertions passed #1.\n");
        1:  139:        trash = 1;
        1:  140:        handPos = rand() % 10;
        1:  141:        checkDiscardCard(handPos, player, state, trash); // trash = 1 check.
        1:  142:        printf("All assertions passed #2.\n");
        1:  143:        state->handCount[player] = 1;
        1:  144:        trash = -1;
        1:  145:        checkDiscardCard(handPos, player, state, trash); // trash = -1 check.
        1:  146:        printf("All assertions passed #3.\n");
        -:  147:
        1:  148:        printf("TESTS OK!\n\n");
        1:  149:        free(state);
        1:  150:        exit(0);
        -:  151:        return 0;
        -:  152:}
File 'unitTest2.c'
Lines executed:95.92% of 49
Branches executed:91.67% of 24
Taken at least once:54.17% of 24
Calls executed:68.00% of 25
unitTest2.c:creating 'unitTest2.c.gcov'

        -:    0:Source:unitTest2.c
        -:    0:Graph:unitTest2.gcno
        -:    0:Data:unitTest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Andrew M. Calhoun
        -:    2:// UNIT TEST - ASSIGNMENT 3
        -:    3:// unitTest2.c
        -:    4:// Unit Test for discardCard function.
        -:    5:
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:#include "rngs.h"
        -:    9:#include <string.h>
        -:   10:#include <stdio.h>
        -:   11:#include <assert.h>
        -:   12:#include <time.h>
        -:   13:#include <stdlib.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:
        -:   17:#define DEBUG 0
        -:   18:#define NOISY_TEST 0
        -:   19:
        -:   20:/* discardCard for Reference
        -:   21:
        -:   22:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -:   23:{
        -:   24:
        -:   25:  //if card is not trashed, added to Played pile
        -:   26:  if (trashFlag < 1)
        -:   27:    {
        -:   28:      //add card to played pile
        -:   29:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
        -:   30:      state->playedCardCount++;
        -:   31:    }
        -:   32:
        -:   33:  //set played card to -1
        -:   34:  state->hand[currentPlayer][handPos] = -1;
        -:   35:
        -:   36:  //remove card from player's hand
        -:   37:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -:   38:    {
        -:   39:      //reduce number of cards in hand
        -:   40:      state->handCount[currentPlayer]--;
        -:   41:    }
        -:   42:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -:   43:    {
        -:   44:      //reduce number of cards in hand
        -:   45:      state->handCount[currentPlayer]--;
        -:   46:    }
        -:   47:  else
        -:   48:    {
        -:   49:      //replace discarded card with last card in hand
        -:   50:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -:   51:      //set last card to -1
        -:   52:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -:   53:      //reduce number of cards in hand
        -:   54:      state->handCount[currentPlayer]--;
        -:   55:    }
        -:   56:
        -:   57:  return 0;
        -:   58:}
        -:   59:
        -:   60:*/
        -:   61:
function checkDiscardCard called 3 returned 100% blocks executed 57%
        3:   62:int checkDiscardCard(int handPos, int currentPlayer, struct gameState *post, int trashFlag)
        -:   63:{
        -:   64:
        3:   65:    struct gameState *pre = malloc(sizeof(struct gameState));
        3:   66:    memcpy(pre, post, sizeof(struct gameState));
        -:   67:    int r;
        -:   68:
        3:   69:    r = discardCard(handPos, currentPlayer, post, trashFlag);
call    0 returned 100%
        -:   70:
        3:   71:    if(trashFlag != 1)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -:   72:    {
        2:   73:        assert(post->playedCards[pre->playedCardCount] == pre->hand[currentPlayer][handPos]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        2:   74:        assert(pre->playedCardCount + 1 == post->playedCardCount);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   75:    }
        -:   76:
        3:   77:    assert(post->hand[currentPlayer][handPos] = -1);
        -:   78:
        3:   79:    if(handPos == (pre->handCount[currentPlayer] - 1))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   80:    {
    #####:   81:        assert(pre->handCount[currentPlayer] - 1 == post->handCount[currentPlayer] );
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   82:    }
        3:   83:    else if (pre->handCount[currentPlayer] == 1)
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:   84:    {
        1:   85:        assert(pre->handCount[currentPlayer] - 1 == post->handCount[currentPlayer]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   86:    }
        -:   87:    else
        -:   88:    {
        2:   89:        assert(pre->hand[currentPlayer][(pre->handCount[currentPlayer])] == post->hand[currentPlayer][ (post->handCount[currentPlayer] + 1 ) ] );
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        2:   90:        assert(post->hand[currentPlayer][post->handCount[currentPlayer]] == -1);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        2:   91:        assert(pre->handCount[currentPlayer] - 1 == post->handCount[currentPlayer] );
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   92:    }
        -:   93:
        3:   94:    assert(r==0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        3:   95:    free(pre);
        3:   96:    return 0;
        -:   97:
        -:   98:}
        -:   99:
function main called 1 returned 0% blocks executed 95%
        1:  100:int main()
        -:  101:{
        1:  102:    srand(time(NULL));
call    0 returned 100%
call    1 returned 100%
        1:  103:    struct gameState *state = malloc(sizeof(struct gameState));
        1:  104:    int player = 0, handPos, trash;
        1:  105:    int k[10] = {adventurer, smithy, great_hall, council_room, baron, minion, mine, village, ambassador, salvager};
        -:  106:
        1:  107:    int seed = rand() % 65535;
call    0 returned 100%
        -:  108:
        1:  109:    initializeGame(2, k, seed, state);
call    0 returned 100%
        -:  110:
        1:  111:    printf("Testing the Discard Card Function\n");
call    0 returned 100%
        -:  112:
        -:  113:    // for(i = 0; i < sizeof(state); i++)
        -:  114:        // printf("Failure Point 1\n");
        -:  115:       //  int handCountConst = floor(Random() * MAX_HAND);
        -:  116:        // p=0;
        1:  117:        handPos = rand() % 10;
call    0 returned 100%
        -:  118:
        1:  119:        state->deckCount[0] = 50;
        1:  120:        state->discardCount[0] = 10;
        1:  121:        state->handCount[0] = 8;
        1:  122:        state->discard[player][state->discardCount[player]] = 100;
        1:  123:        state->playedCardCount = rand() % 10;
call    0 returned 100%
        -:  124:        // printf("Failure Point 2\n");
        -:  125:
        1:  126:        if(handPos > 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  127:        {
        1:  128:            state->playedCards[state->playedCardCount] = state->hand[0][handPos];
        -:  129:        }
        -:  130:        else
        -:  131:        {
    #####:  132:            state->playedCards[state->playedCardCount] = state->hand[0][handPos - 1];
        -:  133:        }
        -:  134:
        1:  135:        trash = 0;
        -:  136:
        1:  137:        checkDiscardCard(handPos, player, state, trash); // trash = 0 check.
call    0 returned 100%
        1:  138:        printf("All assertions passed #1.\n");
call    0 returned 100%
        1:  139:        trash = 1;
        1:  140:        handPos = rand() % 10;
call    0 returned 100%
        1:  141:        checkDiscardCard(handPos, player, state, trash); // trash = 1 check.
call    0 returned 100%
        1:  142:        printf("All assertions passed #2.\n");
call    0 returned 100%
        1:  143:        state->handCount[player] = 1;
        1:  144:        trash = -1;
        1:  145:        checkDiscardCard(handPos, player, state, trash); // trash = -1 check.
call    0 returned 100%
        1:  146:        printf("All assertions passed #3.\n");
call    0 returned 100%
        -:  147:
        1:  148:        printf("TESTS OK!\n\n");
call    0 returned 100%
        1:  149:        free(state);
        1:  150:        exit(0);
call    0 returned 0%
        -:  151:        return 0;
        -:  152:}
File 'unitTest3.c'
Lines executed:97.44% of 39
unitTest3.c:creating 'unitTest3.c.gcov'

        -:    0:Source:unitTest3.c
        -:    0:Graph:unitTest3.gcno
        -:    0:Data:unitTest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Andrew M. Calhoun
        -:    2:// UNIT TEST - ASSIGNMENT 3
        -:    3:// unitTest3.c
        -:    4:// Unit Test for buyCard function.
        -:    5:
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:#include "rngs.h"
        -:    9:#include <string.h>
        -:   10:#include <stdio.h>
        -:   11:#include <assert.h>
        -:   12:#include <time.h>
        -:   13:#include <stdlib.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:
        -:   17:#define DEBUG 0
        -:   18:#define NOISY_TEST 1
        -:   19:
        -:   20:// Ensures that buyCard function works properly and asserts properly.
        -:   21:
        -:   22:
        -:   23:/* function for reference
        -:   24:
        -:   25:int buyCard(int supplyPos, struct gameState *state) {
        -:   26:  int who;
        -:   27:  if (DEBUG){
        -:   28:    printf("Entering buyCard...\n");
        -:   29:  }
        -:   30:
        -:   31:  // I don't know what to do about the phase thing.
        -:   32:
        -:   33:  who = state->whoseTurn;
        -:   34:
        -:   35:  if (state->numBuys < 1){
        -:   36:    if (DEBUG)
        -:   37:      printf("You do not have any buys left\n");
        -:   38:    return -1;
        -:   39:  } else if (supplyCount(supplyPos, state) <1){
        -:   40:    if (DEBUG)
        -:   41:      printf("There are not any of that type of card left\n");
        -:   42:    return -1;
        -:   43:  } else if (state->coins < getCost(supplyPos)){
        -:   44:    if (DEBUG)
        -:   45:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        -:   46:    return -1;
        -:   47:  } else {
        -:   48:    state->phase=1;
        -:   49:    //state->supplyCount[supplyPos]--;
        -:   50:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:   51:
        -:   52:    state->coins = (state->coins) - (getCost(supplyPos));
        -:   53:    state->numBuys--;
        -:   54:    if (DEBUG)
        -:   55:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:   56:  }
        -:   57:
        -:   58:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:   59:  //state->discardCount[who]++;
        -:   60:
        -:   61:  return 0;
        -:   62:} */
      200:   63:int checkBuyCard(int supplyPos, struct gameState *state)
        -:   64:{
        -:   65:    int who;
        -:   66:    // if needed
        -:   67:    struct gameState pre;
      200:   68:    memcpy(&pre, state, sizeof(struct gameState));
        -:   69:    //
      200:   70:    printf("Testing Buy Card Functionality\n\n");
        -:   71:
      200:   72:    who = state->whoseTurn;
        -:   73:
      200:   74:    if(state->numBuys < 1)
        -:   75:    {
       32:   76:        assert(state->numBuys > -1); // Make sure it doesn't go below 0.
       32:   77:        printf("You have no buys left. 0 Buy Test Passed.\n\n");
       32:   78:        return 0;
        -:   79:    }
        -:   80:    else
        -:   81:    {
      168:   82:        assert(state->phase=1); // Ensure that the game is in buy phase.
      168:   83:        assert(state->numBuys >= 1);
      168:   84:        printf("One or more buys available test passed.\n");
      168:   85:        if(supplyCount(supplyPos, state) < 1)
        -:   86:        {
       62:   87:            printf("Out of that particular card!\n");
       62:   88:            return 0;
        -:   89:        }
      106:   90:        printf("Card supply available.\n");
      106:   91:        if (state->coins >= getCost(supplyPos))
        -:   92:        {
      106:   93:            printf("Can buy card with available gold. Yes!\n");
        -:   94:        }
        -:   95:        else
        -:   96:        {
    #####:   97:            printf("Thou hast not enough gold!\n");
        -:   98:        }
      106:   99:        buyCard(supplyPos, state);
      106:  100:        assert(state->numBuys == pre.numBuys - 1);
      106:  101:        assert(state->numBuys >= 0);
      106:  102:        assert(state->coins == (pre.coins - getCost(supplyPos)));
        -:  103:
      106:  104:        return 0;
        -:  105:    }
        -:  106:
        -:  107:}
        -:  108:
        1:  109:int main()
        -:  110:{
        1:  111:    srand(time(NULL));
        1:  112:    int seed = rand() % 65535;
        -:  113:    int coinage, buyage;
        -:  114:    int supplyPos;
        -:  115:    int i;
        1:  116:    int k[10] = { adventurer, smithy, village, baron, salvager, sea_hag, great_hall, minion, council_room, gardens };
        1:  117:    struct gameState *state = malloc(sizeof(struct gameState));
        -:  118:
        1:  119:    initializeGame(2, k, seed, state);
        -:  120:
      201:  121:    for(i=0; i<200; i++)
        -:  122:    {
      200:  123:        supplyPos = rand() % 9; // tried with all cards, but can only allow kingdom cards.
      200:  124:        coinage = rand() % 16 + 8;
      200:  125:        buyage = rand() % 8;
      200:  126:        state->coins = coinage;
      200:  127:        state->numBuys = buyage; // for random testing.
        -:  128:
      200:  129:        checkBuyCard(supplyPos, state);
        -:  130:    }
        -:  131:
        1:  132:    printf("\n\nAll tests passed!\n");
        -:  133:
        -:  134:
        1:  135:    free(state);
        1:  136:    return 0;
        -:  137:
        -:  138:}
File 'unitTest3.c'
Lines executed:97.44% of 39
Branches executed:100.00% of 18
Taken at least once:66.67% of 18
Calls executed:76.00% of 25
unitTest3.c:creating 'unitTest3.c.gcov'

        -:    0:Source:unitTest3.c
        -:    0:Graph:unitTest3.gcno
        -:    0:Data:unitTest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Andrew M. Calhoun
        -:    2:// UNIT TEST - ASSIGNMENT 3
        -:    3:// unitTest3.c
        -:    4:// Unit Test for buyCard function.
        -:    5:
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:#include "rngs.h"
        -:    9:#include <string.h>
        -:   10:#include <stdio.h>
        -:   11:#include <assert.h>
        -:   12:#include <time.h>
        -:   13:#include <stdlib.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:
        -:   17:#define DEBUG 0
        -:   18:#define NOISY_TEST 1
        -:   19:
        -:   20:// Ensures that buyCard function works properly and asserts properly.
        -:   21:
        -:   22:
        -:   23:/* function for reference
        -:   24:
        -:   25:int buyCard(int supplyPos, struct gameState *state) {
        -:   26:  int who;
        -:   27:  if (DEBUG){
        -:   28:    printf("Entering buyCard...\n");
        -:   29:  }
        -:   30:
        -:   31:  // I don't know what to do about the phase thing.
        -:   32:
        -:   33:  who = state->whoseTurn;
        -:   34:
        -:   35:  if (state->numBuys < 1){
        -:   36:    if (DEBUG)
        -:   37:      printf("You do not have any buys left\n");
        -:   38:    return -1;
        -:   39:  } else if (supplyCount(supplyPos, state) <1){
        -:   40:    if (DEBUG)
        -:   41:      printf("There are not any of that type of card left\n");
        -:   42:    return -1;
        -:   43:  } else if (state->coins < getCost(supplyPos)){
        -:   44:    if (DEBUG)
        -:   45:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        -:   46:    return -1;
        -:   47:  } else {
        -:   48:    state->phase=1;
        -:   49:    //state->supplyCount[supplyPos]--;
        -:   50:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:   51:
        -:   52:    state->coins = (state->coins) - (getCost(supplyPos));
        -:   53:    state->numBuys--;
        -:   54:    if (DEBUG)
        -:   55:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:   56:  }
        -:   57:
        -:   58:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:   59:  //state->discardCount[who]++;
        -:   60:
        -:   61:  return 0;
        -:   62:} */
function checkBuyCard called 200 returned 100% blocks executed 79%
      200:   63:int checkBuyCard(int supplyPos, struct gameState *state)
        -:   64:{
        -:   65:    int who;
        -:   66:    // if needed
        -:   67:    struct gameState pre;
      200:   68:    memcpy(&pre, state, sizeof(struct gameState));
        -:   69:    //
      200:   70:    printf("Testing Buy Card Functionality\n\n");
call    0 returned 100%
        -:   71:
      200:   72:    who = state->whoseTurn;
        -:   73:
      200:   74:    if(state->numBuys < 1)
branch  0 taken 16% (fallthrough)
branch  1 taken 84%
        -:   75:    {
       32:   76:        assert(state->numBuys > -1); // Make sure it doesn't go below 0.
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       32:   77:        printf("You have no buys left. 0 Buy Test Passed.\n\n");
call    0 returned 100%
       32:   78:        return 0;
        -:   79:    }
        -:   80:    else
        -:   81:    {
      168:   82:        assert(state->phase=1); // Ensure that the game is in buy phase.
      168:   83:        assert(state->numBuys >= 1);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      168:   84:        printf("One or more buys available test passed.\n");
call    0 returned 100%
      168:   85:        if(supplyCount(supplyPos, state) < 1)
call    0 returned 100%
branch  1 taken 37% (fallthrough)
branch  2 taken 63%
        -:   86:        {
       62:   87:            printf("Out of that particular card!\n");
call    0 returned 100%
       62:   88:            return 0;
        -:   89:        }
      106:   90:        printf("Card supply available.\n");
call    0 returned 100%
      106:   91:        if (state->coins >= getCost(supplyPos))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:   92:        {
      106:   93:            printf("Can buy card with available gold. Yes!\n");
call    0 returned 100%
        -:   94:        }
        -:   95:        else
        -:   96:        {
    #####:   97:            printf("Thou hast not enough gold!\n");
call    0 never executed
        -:   98:        }
      106:   99:        buyCard(supplyPos, state);
call    0 returned 100%
      106:  100:        assert(state->numBuys == pre.numBuys - 1);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      106:  101:        assert(state->numBuys >= 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      106:  102:        assert(state->coins == (pre.coins - getCost(supplyPos)));
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:  103:
      106:  104:        return 0;
        -:  105:    }
        -:  106:
        -:  107:}
        -:  108:
function main called 1 returned 100% blocks executed 100%
        1:  109:int main()
        -:  110:{
        1:  111:    srand(time(NULL));
call    0 returned 100%
call    1 returned 100%
        1:  112:    int seed = rand() % 65535;
call    0 returned 100%
        -:  113:    int coinage, buyage;
        -:  114:    int supplyPos;
        -:  115:    int i;
        1:  116:    int k[10] = { adventurer, smithy, village, baron, salvager, sea_hag, great_hall, minion, council_room, gardens };
        1:  117:    struct gameState *state = malloc(sizeof(struct gameState));
        -:  118:
        1:  119:    initializeGame(2, k, seed, state);
call    0 returned 100%
        -:  120:
      201:  121:    for(i=0; i<200; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  122:    {
      200:  123:        supplyPos = rand() % 9; // tried with all cards, but can only allow kingdom cards.
call    0 returned 100%
      200:  124:        coinage = rand() % 16 + 8;
call    0 returned 100%
      200:  125:        buyage = rand() % 8;
call    0 returned 100%
      200:  126:        state->coins = coinage;
      200:  127:        state->numBuys = buyage; // for random testing.
        -:  128:
      200:  129:        checkBuyCard(supplyPos, state);
call    0 returned 100%
        -:  130:    }
        -:  131:
        1:  132:    printf("\n\nAll tests passed!\n");
call    0 returned 100%
        -:  133:
        -:  134:
        1:  135:    free(state);
        1:  136:    return 0;
        -:  137:
        -:  138:}
File 'unitTest4.c'
Lines executed:95.45% of 44
unitTest4.c:creating 'unitTest4.c.gcov'

        -:    0:Source:unitTest4.c
        -:    0:Graph:unitTest4.gcno
        -:    0:Data:unitTest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Andrew M. Calhoun
        -:    2:// UNIT TEST - ASSIGNMENT 3
        -:    3:// unitTest4.c
        -:    4:// Unit Test for checkEndTurn function.
        -:    5:
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:#include "rngs.h"
        -:    9:#include <string.h>
        -:   10:#include <stdio.h>
        -:   11:#include <assert.h>
        -:   12:#include <time.h>
        -:   13:#include <stdlib.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:
        -:   17:#define DEBUG 0
        -:   18:#define NOISY_TEST 1
        -:   19:
        -:   20:
        -:   21:/*
        -:   22:
        -:   23:int endTurn(struct gameState *state) {
        -:   24:  int k;
        -:   25:  int i;
        -:   26:  int currentPlayer = whoseTurn(state);
        -:   27:
        -:   28:  //Discard hand
        -:   29:  for (i = 0; i < state->handCount[currentPlayer]; i++){
        -:   30:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
        -:   31:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:   32:  }
        -:   33:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:   34:
        -:   35:  //Code for determining the player
        -:   36:  if (currentPlayer < (state->numPlayers - 1)){
        -:   37:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:   38:  }
        -:   39:  else{
        -:   40:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:   41:  }
        -:   42:
        -:   43:  state->outpostPlayed = 0;
        -:   44:  state->phase = 0;
        -:   45:  state->numActions = 1;
        -:   46:  state->coins = 0;
        -:   47:  state->numBuys = 1;
        -:   48:  state->playedCardCount = 0;
        -:   49:  state->handCount[state->whoseTurn] = 0;
        -:   50:
        -:   51:  //int k; move to top
        -:   52:  //Next player draws hand
        -:   53:  for (k = 0; k < 5; k++){
        -:   54:    drawCard(state->whoseTurn, state);//Draw a card
        -:   55:  }
        -:   56:
        -:   57:  //Update money
        -:   58:  updateCoins(state->whoseTurn, state , 0);
        -:   59:
        -:   60:  return 0;
        -:   61:}
        -:   62:
        -:   63:*/
        -:   64:
        1:   65:int checkEndTurn(struct gameState *post)
        -:   66:{
        -:   67:    int k, i, j;
        1:   68:    int currentPlayer = whoseTurn(post);
        -:   69:    struct gameState pre;
        1:   70:    memcpy(&pre, post, sizeof(struct gameState));
        -:   71:
        1:   72:    printf("Assertions to ensure cards are discarded properly at end of each turn.\n");
        -:   73:
        2:   74:    for(i=0; i<pre.handCount[currentPlayer]; i++)
        -:   75:    {
        1:   76:        pre.discard[currentPlayer][pre.discardCount[currentPlayer]++] = pre.hand[currentPlayer][i];
        1:   77:        assert(pre.discard[currentPlayer][pre.discardCount[currentPlayer]++] == post->discard[currentPlayer][post->discardCount[currentPlayer]++]);
        1:   78:        assert(post->discard[currentPlayer][post->discardCount[currentPlayer]++] != pre.hand[currentPlayer][i]);
        -:   79:
        -:   80:       //  printf("%d\n%d\n", pre.hand[currentPlayer][i], post->hand[currentPlayer][i]);
        -:   81:
        1:   82:        pre.hand[currentPlayer][i] = -1;//Set card to -1
        1:   83:        assert(pre.hand[currentPlayer][i] = post->hand[currentPlayer][i] - 2);
        -:   84:
        1:   85:        assert(post->hand[currentPlayer][i] + 1 >= pre.hand[currentPlayer][i]);
        -:   86:
        1:   87:        printf("Post Turn End: %d\n Pre Turn End: %d\n", post->handCount[currentPlayer], pre.handCount[currentPlayer]);
        1:   88:        post->handCount[currentPlayer] = pre.handCount[currentPlayer] = 0;
        -:   89:
        1:   90:        assert(post->handCount[currentPlayer] == pre.handCount[currentPlayer]); // These should match.
        -:   91:
        -:   92:    }
        -:   93:
        1:   94:    printf("Discard Assertions passed.\n");
        -:   95:
        1:   96:    printf("Player Counts -- makes sure player is properly selected.\n");
        -:   97:
        1:   98:    if (currentPlayer < (post->numPlayers - 1))
        -:   99:    {
        1:  100:        post->whoseTurn = currentPlayer + 1;//Still safe to increment
        1:  101:        assert(post->whoseTurn - (currentPlayer + 1) == pre.whoseTurn);
        -:  102:    }
        -:  103:    else{
    #####:  104:        pre.whoseTurn = post->whoseTurn = 0;//Max player has been reached, loop back around to player 1
    #####:  105:        assert(pre.whoseTurn == post->whoseTurn);
        -:  106:    }
        -:  107:
        1:  108:    printf("Player Turn Counter Works Correctly\n");
        -:  109:
        1:  110:    printf("Assertion Tests for Outposts, Action Counts, and Coins. All Should Be Equal.\n");
        -:  111:
        1:  112:    assert(pre.outpostPlayed == post->outpostPlayed);
        1:  113:    assert(pre.phase == post->phase);
        1:  114:    assert(pre.numActions == post->numActions);
        1:  115:    assert(pre.coins == post->coins);
        1:  116:    assert(post->numBuys == pre.numBuys);
        1:  117:    assert(post->playedCardCount == pre.playedCardCount);
        1:  118:    assert(pre.handCount[post->whoseTurn] == post->handCount[pre.whoseTurn]);
        -:  119:
        1:  120:    printf("All assertions passed.\n");
        -:  121:
        -:  122:     //int k; move to top
        -:  123:  //Next player draws hand
        6:  124:  for (k = 0; k < 5; k++){
        5:  125:    j = drawCard(pre.whoseTurn, &pre);//Draw a card
        5:  126:    i = drawCard(post->whoseTurn, post);
        5:  127:    assert(j == i); // Broken -- is there a way to properly test this without destroying the program?
        -:  128:  }
        -:  129:
        1:  130:    return 0;
        -:  131:}
        -:  132:
        -:  133:
        1:  134:int main()
        -:  135:{
        1:  136:    srand(time(NULL));
        1:  137:    int seed = rand() % 65535;
        1:  138:    int k[10] = { adventurer, smithy, village, baron, great_hall, council_room, salvager, sea_hag, gardens, mine };
        1:  139:    struct gameState *state = malloc(sizeof(struct gameState));
        -:  140:
        1:  141:    initializeGame(2, k, seed, state);
        -:  142:
        1:  143:    checkEndTurn(state);
        -:  144:
        1:  145:    return 0;
        -:  146:
        -:  147:}
File 'unitTest4.c'
Lines executed:95.45% of 44
Branches executed:94.44% of 36
Taken at least once:52.78% of 36
Calls executed:50.00% of 30
unitTest4.c:creating 'unitTest4.c.gcov'

        -:    0:Source:unitTest4.c
        -:    0:Graph:unitTest4.gcno
        -:    0:Data:unitTest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Andrew M. Calhoun
        -:    2:// UNIT TEST - ASSIGNMENT 3
        -:    3:// unitTest4.c
        -:    4:// Unit Test for checkEndTurn function.
        -:    5:
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:#include "rngs.h"
        -:    9:#include <string.h>
        -:   10:#include <stdio.h>
        -:   11:#include <assert.h>
        -:   12:#include <time.h>
        -:   13:#include <stdlib.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:
        -:   17:#define DEBUG 0
        -:   18:#define NOISY_TEST 1
        -:   19:
        -:   20:
        -:   21:/*
        -:   22:
        -:   23:int endTurn(struct gameState *state) {
        -:   24:  int k;
        -:   25:  int i;
        -:   26:  int currentPlayer = whoseTurn(state);
        -:   27:
        -:   28:  //Discard hand
        -:   29:  for (i = 0; i < state->handCount[currentPlayer]; i++){
        -:   30:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
        -:   31:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:   32:  }
        -:   33:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:   34:
        -:   35:  //Code for determining the player
        -:   36:  if (currentPlayer < (state->numPlayers - 1)){
        -:   37:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:   38:  }
        -:   39:  else{
        -:   40:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:   41:  }
        -:   42:
        -:   43:  state->outpostPlayed = 0;
        -:   44:  state->phase = 0;
        -:   45:  state->numActions = 1;
        -:   46:  state->coins = 0;
        -:   47:  state->numBuys = 1;
        -:   48:  state->playedCardCount = 0;
        -:   49:  state->handCount[state->whoseTurn] = 0;
        -:   50:
        -:   51:  //int k; move to top
        -:   52:  //Next player draws hand
        -:   53:  for (k = 0; k < 5; k++){
        -:   54:    drawCard(state->whoseTurn, state);//Draw a card
        -:   55:  }
        -:   56:
        -:   57:  //Update money
        -:   58:  updateCoins(state->whoseTurn, state , 0);
        -:   59:
        -:   60:  return 0;
        -:   61:}
        -:   62:
        -:   63:*/
        -:   64:
function checkEndTurn called 1 returned 100% blocks executed 67%
        1:   65:int checkEndTurn(struct gameState *post)
        -:   66:{
        -:   67:    int k, i, j;
        1:   68:    int currentPlayer = whoseTurn(post);
call    0 returned 100%
        -:   69:    struct gameState pre;
        1:   70:    memcpy(&pre, post, sizeof(struct gameState));
        -:   71:
        1:   72:    printf("Assertions to ensure cards are discarded properly at end of each turn.\n");
call    0 returned 100%
        -:   73:
        2:   74:    for(i=0; i<pre.handCount[currentPlayer]; i++)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -:   75:    {
        1:   76:        pre.discard[currentPlayer][pre.discardCount[currentPlayer]++] = pre.hand[currentPlayer][i];
        1:   77:        assert(pre.discard[currentPlayer][pre.discardCount[currentPlayer]++] == post->discard[currentPlayer][post->discardCount[currentPlayer]++]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        1:   78:        assert(post->discard[currentPlayer][post->discardCount[currentPlayer]++] != pre.hand[currentPlayer][i]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   79:
        -:   80:       //  printf("%d\n%d\n", pre.hand[currentPlayer][i], post->hand[currentPlayer][i]);
        -:   81:
        1:   82:        pre.hand[currentPlayer][i] = -1;//Set card to -1
        1:   83:        assert(pre.hand[currentPlayer][i] = post->hand[currentPlayer][i] - 2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   84:
        1:   85:        assert(post->hand[currentPlayer][i] + 1 >= pre.hand[currentPlayer][i]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   86:
        1:   87:        printf("Post Turn End: %d\n Pre Turn End: %d\n", post->handCount[currentPlayer], pre.handCount[currentPlayer]);
call    0 returned 100%
        1:   88:        post->handCount[currentPlayer] = pre.handCount[currentPlayer] = 0;
        -:   89:
        1:   90:        assert(post->handCount[currentPlayer] == pre.handCount[currentPlayer]); // These should match.
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   91:
        -:   92:    }
        -:   93:
        1:   94:    printf("Discard Assertions passed.\n");
call    0 returned 100%
        -:   95:
        1:   96:    printf("Player Counts -- makes sure player is properly selected.\n");
call    0 returned 100%
        -:   97:
        1:   98:    if (currentPlayer < (post->numPlayers - 1))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   99:    {
        1:  100:        post->whoseTurn = currentPlayer + 1;//Still safe to increment
        1:  101:        assert(post->whoseTurn - (currentPlayer + 1) == pre.whoseTurn);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  102:    }
        -:  103:    else{
    #####:  104:        pre.whoseTurn = post->whoseTurn = 0;//Max player has been reached, loop back around to player 1
    #####:  105:        assert(pre.whoseTurn == post->whoseTurn);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  106:    }
        -:  107:
        1:  108:    printf("Player Turn Counter Works Correctly\n");
call    0 returned 100%
        -:  109:
        1:  110:    printf("Assertion Tests for Outposts, Action Counts, and Coins. All Should Be Equal.\n");
call    0 returned 100%
        -:  111:
        1:  112:    assert(pre.outpostPlayed == post->outpostPlayed);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        1:  113:    assert(pre.phase == post->phase);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        1:  114:    assert(pre.numActions == post->numActions);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        1:  115:    assert(pre.coins == post->coins);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        1:  116:    assert(post->numBuys == pre.numBuys);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        1:  117:    assert(post->playedCardCount == pre.playedCardCount);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        1:  118:    assert(pre.handCount[post->whoseTurn] == post->handCount[pre.whoseTurn]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  119:
        1:  120:    printf("All assertions passed.\n");
call    0 returned 100%
        -:  121:
        -:  122:     //int k; move to top
        -:  123:  //Next player draws hand
        6:  124:  for (k = 0; k < 5; k++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        5:  125:    j = drawCard(pre.whoseTurn, &pre);//Draw a card
call    0 returned 100%
        5:  126:    i = drawCard(post->whoseTurn, post);
call    0 returned 100%
        5:  127:    assert(j == i); // Broken -- is there a way to properly test this without destroying the program?
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  128:  }
        -:  129:
        1:  130:    return 0;
        -:  131:}
        -:  132:
        -:  133:
function main called 1 returned 100% blocks executed 100%
        1:  134:int main()
        -:  135:{
        1:  136:    srand(time(NULL));
call    0 returned 100%
call    1 returned 100%
        1:  137:    int seed = rand() % 65535;
call    0 returned 100%
        1:  138:    int k[10] = { adventurer, smithy, village, baron, great_hall, council_room, salvager, sea_hag, gardens, mine };
        1:  139:    struct gameState *state = malloc(sizeof(struct gameState));
        -:  140:
        1:  141:    initializeGame(2, k, seed, state);
call    0 returned 100%
        -:  142:
        1:  143:    checkEndTurn(state);
call    0 returned 100%
        -:  144:
        1:  145:    return 0;
        -:  146:
        -:  147:}
File 'cardTest1.c'
Lines executed:88.06% of 67
cardTest1.c:creating 'cardTest1.c.gcov'

        -:    0:Source:cardTest1.c
        -:    0:Graph:cardTest1.gcno
        -:    0:Data:cardTest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Andrew M. Calhoun
        -:    2:// UNIT TEST - ASSIGNMENT 3
        -:    3:// unitTest1.c
        -:    4:// Unit Test for card function -- ADVENTURER.
        -:    5:// cardtest1: cardtest1.c dominion.o rngs.o
        -:    6://       gcc -o cardtest1 -g  cardtest1.c dominion.o rngs.o $(CFLAGS)
        -:    7:
        -:    8:
        -:    9:
        -:   10:#include "dominion.h"
        -:   11:#include "dominion_helpers.h"
        -:   12:#include "rngs.h"
        -:   13:#include <string.h>
        -:   14:#include <stdio.h>
        -:   15:#include <assert.h>
        -:   16:#include <time.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <math.h>
        -:   19:#include <stdlib.h>
        -:   20:
        -:   21:#define DEBUG 0
        -:   22:#define NOISY_TEST 1
        -:   23:#define TESTCARD "adventurer"
        -:   24:
        -:   25:/*
        -:   26:
        -:   27:int playAdventurer(struct gameState *state, int currentPlayer, int cardDrawn, int drawntreasure, int temphand[], int z)
        -:   28:{
        -:   29:
        -:   30:      while(drawntreasure<2){
        -:   31:	if (state->deckCount[currentPlayer] <=1)
        -:   32:        {//if the deck is empty we need to shuffle discard and add to deck *** REFACTOR to <= will cause additional shuffling.
        -:   33:	  shuffle(currentPlayer, state);
        -:   34:        }
        -:   35:        drawCard(currentPlayer, state);
        -:   36:        cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
        -:   37:        if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        -:   38:	  drawntreasure+=2; // The adventurer should not make off with your treasure. Originally had this put as --, but it actually caused the game to freeze. Opted to give the player more coins. Changes seeded outcomes.
        -:   39:	else{
        -:   40:	  temphand[z]=cardDrawn;
        -:   41:	  state->handCount[currentPlayer]++; //this should just remove the top card (the most recently drawn one).
        -:   42:	  z++;
        -:   43:	}
        -:   44:      }
        -:   45:      while(z-1>=0){
        -:   46:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
        -:   47:	z=z-1;
        -:   48:      }
        -:   49:      return 0;
        -:   50:}
        -:   51:
        -:   52:*/
        -:   53:
       20:   54:int checkPlayAdventurer(struct gameState *state, int currentPlayer, int cardDrawn, int drawnTreasure, int temphand[], int z)
        -:   55:{
       20:   56:    int preDraw, failTest = 0;
        -:   57:    // int x;
        -:   58:    struct gameState testState;
       20:   59:    memcpy(&testState, state, sizeof(struct gameState));
        -:   60:
       20:   61:    printf("\nChecking Drawn Treasure.\nDrawn Treasure: %d\n", drawnTreasure);
        -:   62:
       20:   63:    printf("Initiating randomized deckCount: 1-5\n");
       20:   64:    state->deckCount[currentPlayer] = rand() % 3;
        -:   65:
       20:   66:    printf("Deck Count: %d\n", state->deckCount[currentPlayer]);
        -:   67:
       20:   68:    preDraw = drawnTreasure;
        -:   69:
       52:   70:    while(drawnTreasure < 2)   // less than two drawn treasure...
        -:   71:    {
       20:   72:        if(state->deckCount[currentPlayer] <= 1)
        -:   73:        {
       12:   74:            shuffle(currentPlayer, &testState);
       12:   75:            if(state->deckCount[currentPlayer] == 0)
        -:   76:            {
        7:   77:                printf("Deck shuffled at 0 properly. Test Passed.\n");
        -:   78:            }
        -:   79:            else
        -:   80:            {
        5:   81:                printf("Deck shuffled at 1. Test Failed.\n");
        5:   82:                failTest = 1;
        -:   83:            }
       12:   84:            drawCard(currentPlayer, &testState);
       12:   85:            cardDrawn = testState.hand[currentPlayer][state->handCount[currentPlayer]-1];
       24:   86:            if(cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        -:   87:            {
       12:   88:                drawnTreasure+=2;   // will add too much treasure. Will always fail.
       12:   89:                if(preDraw++ == drawnTreasure)
        -:   90:                {
    #####:   91:                    printf("Treasure Draw Check Passed");
        -:   92:                }
        -:   93:                else
        -:   94:                {
       12:   95:                    printf("Treasure Draw Check Failed.");
       12:   96:                    failTest = 1;
        -:   97:                }
        -:   98:
        -:   99:
        -:  100:            }
        -:  101:            else
        -:  102:            {
    #####:  103:                temphand[z] = cardDrawn;
    #####:  104:                testState.handCount[currentPlayer]++;
    #####:  105:                z++;
        -:  106:            }
        -:  107:
        -:  108:        }
        -:  109:
        -:  110:        else
        -:  111:        {
        8:  112:            printf("No shuffle. Test Passed.\n");
        8:  113:            break;
        -:  114:            // shuffled = 0;
        -:  115:        }
        -:  116:    }
        -:  117:
       20:  118:    printf("Testing Coins. Should only add 1\n\n");
       20:  119:    if(testState.coins == state->coins++)
        -:  120:    {
       20:  121:        printf("State Coin Test passed.\n");
        -:  122:    }
        -:  123:    else
        -:  124:    {
    #####:  125:        printf("State Coin Test failed.\n");
    #####:  126:        failTest = 1;
        -:  127:    }
        -:  128:
        -:  129:
       20:  130:    printf("Previous Hand Count: %d\n", state->handCount[currentPlayer]);
       20:  131:    printf("Current Hand Count: %d\n", testState.handCount[currentPlayer]);
        -:  132:
       40:  133:    while(z-1>=0){
    #####:  134:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  135:	z=z-1;
        -:  136:    }
        -:  137:
       20:  138:    return failTest;
        -:  139:}
        -:  140:
        1:  141:int main()
        -:  142:{
        -:  143:    // Set up the test harness.
        -:  144:
        1:  145:    srand(time(NULL));
        1:  146:    int x, i, testSuiteSuccess = 0, testSuiteFailure = 0, testsRun = 0;
        1:  147:    int seed = 1000; // Perhaps having a set seed would standardize testing, but we need ALL situations tested, even those we don't anticipate.
        1:  148:    int k[10] = { adventurer, smithy, village, baron, great_hall, council_room, salvager, sea_hag, gardens, mine };
        -:  149:    // const char *cards[] = { "curse", "estate", "duchy", "province", "copper", "silver", "gold", "adventurer", "council_room", "feast", "gardens", "mine", "remodel", "smithy", "village", "baron",
        -:  150:    // "great_hall", "minion", "steward", "tribute", "ambassador", "cutpurse", "embargo", "outpost", "salvager", "sea_hag", "treasure_map" };
        1:  151:    int randomCard = 0; //rand() % 10;
        1:  152:    int z = 0;
        1:  153:    int drawnTreasure = rand() % 3;
        -:  154:
        1:  155:    struct gameState *post = malloc(sizeof(struct gameState));
        -:  156:    int temphand[MAX_HAND];
        1:  157:    initializeGame(2, k, seed, post);
        -:  158:
      501:  159:    for(i=0; i < MAX_HAND; i++)
        -:  160:    {
      500:  161:        if(i < 2)
        -:  162:        {
        2:  163:           temphand[i] = copper;
        -:  164:        }
        -:  165:        else
        -:  166:        {
      498:  167:            temphand[i] = k[i];
        -:  168:        }
        -:  169:    }
        -:  170:
        1:  171:    printf("Testing Adventurer!\n");
       21:  172:    for(i=0; i < 20; i++)
        -:  173:    {
       20:  174:        x = checkPlayAdventurer(post, 0, randomCard, drawnTreasure, temphand, z);
       20:  175:        if(x)
        -:  176:        {
       12:  177:            printf("One or More Assertion and Gameplay Tests Failed.\n");
       12:  178:            testSuiteFailure++;
       12:  179:            testsRun++;
        -:  180:        }
        -:  181:        else
        -:  182:        {
        8:  183:            printf("All Assertion and Gameplay Tests Passed!\n");
        8:  184:            testSuiteSuccess++;
        8:  185:            testsRun++;
        -:  186:        }
        -:  187:    }
        -:  188:
        1:  189:    printf("Successes / Tests Run: %d / %d\n", testSuiteSuccess, testsRun);
        1:  190:    printf("Failures / Tests Run: %d / %d\n", testSuiteFailure, testsRun);
        -:  191:
        1:  192:    free(post);
        1:  193:    return 0;
        -:  194:}
File 'cardTest1.c'
Lines executed:88.06% of 67
Branches executed:84.62% of 26
Taken at least once:69.23% of 26
Calls executed:92.31% of 26
cardTest1.c:creating 'cardTest1.c.gcov'

        -:    0:Source:cardTest1.c
        -:    0:Graph:cardTest1.gcno
        -:    0:Data:cardTest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Andrew M. Calhoun
        -:    2:// UNIT TEST - ASSIGNMENT 3
        -:    3:// unitTest1.c
        -:    4:// Unit Test for card function -- ADVENTURER.
        -:    5:// cardtest1: cardtest1.c dominion.o rngs.o
        -:    6://       gcc -o cardtest1 -g  cardtest1.c dominion.o rngs.o $(CFLAGS)
        -:    7:
        -:    8:
        -:    9:
        -:   10:#include "dominion.h"
        -:   11:#include "dominion_helpers.h"
        -:   12:#include "rngs.h"
        -:   13:#include <string.h>
        -:   14:#include <stdio.h>
        -:   15:#include <assert.h>
        -:   16:#include <time.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <math.h>
        -:   19:#include <stdlib.h>
        -:   20:
        -:   21:#define DEBUG 0
        -:   22:#define NOISY_TEST 1
        -:   23:#define TESTCARD "adventurer"
        -:   24:
        -:   25:/*
        -:   26:
        -:   27:int playAdventurer(struct gameState *state, int currentPlayer, int cardDrawn, int drawntreasure, int temphand[], int z)
        -:   28:{
        -:   29:
        -:   30:      while(drawntreasure<2){
        -:   31:	if (state->deckCount[currentPlayer] <=1)
        -:   32:        {//if the deck is empty we need to shuffle discard and add to deck *** REFACTOR to <= will cause additional shuffling.
        -:   33:	  shuffle(currentPlayer, state);
        -:   34:        }
        -:   35:        drawCard(currentPlayer, state);
        -:   36:        cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
        -:   37:        if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        -:   38:	  drawntreasure+=2; // The adventurer should not make off with your treasure. Originally had this put as --, but it actually caused the game to freeze. Opted to give the player more coins. Changes seeded outcomes.
        -:   39:	else{
        -:   40:	  temphand[z]=cardDrawn;
        -:   41:	  state->handCount[currentPlayer]++; //this should just remove the top card (the most recently drawn one).
        -:   42:	  z++;
        -:   43:	}
        -:   44:      }
        -:   45:      while(z-1>=0){
        -:   46:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
        -:   47:	z=z-1;
        -:   48:      }
        -:   49:      return 0;
        -:   50:}
        -:   51:
        -:   52:*/
        -:   53:
function checkPlayAdventurer called 20 returned 100% blocks executed 81%
       20:   54:int checkPlayAdventurer(struct gameState *state, int currentPlayer, int cardDrawn, int drawnTreasure, int temphand[], int z)
        -:   55:{
       20:   56:    int preDraw, failTest = 0;
        -:   57:    // int x;
        -:   58:    struct gameState testState;
       20:   59:    memcpy(&testState, state, sizeof(struct gameState));
        -:   60:
       20:   61:    printf("\nChecking Drawn Treasure.\nDrawn Treasure: %d\n", drawnTreasure);
call    0 returned 100%
        -:   62:
       20:   63:    printf("Initiating randomized deckCount: 1-5\n");
call    0 returned 100%
       20:   64:    state->deckCount[currentPlayer] = rand() % 3;
call    0 returned 100%
        -:   65:
       20:   66:    printf("Deck Count: %d\n", state->deckCount[currentPlayer]);
call    0 returned 100%
        -:   67:
       20:   68:    preDraw = drawnTreasure;
        -:   69:
       52:   70:    while(drawnTreasure < 2)   // less than two drawn treasure...
branch  0 taken 63%
branch  1 taken 38% (fallthrough)
        -:   71:    {
       20:   72:        if(state->deckCount[currentPlayer] <= 1)
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
        -:   73:        {
       12:   74:            shuffle(currentPlayer, &testState);
call    0 returned 100%
       12:   75:            if(state->deckCount[currentPlayer] == 0)
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
        -:   76:            {
        7:   77:                printf("Deck shuffled at 0 properly. Test Passed.\n");
call    0 returned 100%
        -:   78:            }
        -:   79:            else
        -:   80:            {
        5:   81:                printf("Deck shuffled at 1. Test Failed.\n");
call    0 returned 100%
        5:   82:                failTest = 1;
        -:   83:            }
       12:   84:            drawCard(currentPlayer, &testState);
call    0 returned 100%
       12:   85:            cardDrawn = testState.hand[currentPlayer][state->handCount[currentPlayer]-1];
       24:   86:            if(cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:   87:            {
       12:   88:                drawnTreasure+=2;   // will add too much treasure. Will always fail.
       12:   89:                if(preDraw++ == drawnTreasure)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   90:                {
    #####:   91:                    printf("Treasure Draw Check Passed");
call    0 never executed
        -:   92:                }
        -:   93:                else
        -:   94:                {
       12:   95:                    printf("Treasure Draw Check Failed.");
call    0 returned 100%
       12:   96:                    failTest = 1;
        -:   97:                }
        -:   98:
        -:   99:
        -:  100:            }
        -:  101:            else
        -:  102:            {
    #####:  103:                temphand[z] = cardDrawn;
    #####:  104:                testState.handCount[currentPlayer]++;
    #####:  105:                z++;
        -:  106:            }
        -:  107:
        -:  108:        }
        -:  109:
        -:  110:        else
        -:  111:        {
        8:  112:            printf("No shuffle. Test Passed.\n");
call    0 returned 100%
        8:  113:            break;
        -:  114:            // shuffled = 0;
        -:  115:        }
        -:  116:    }
        -:  117:
       20:  118:    printf("Testing Coins. Should only add 1\n\n");
call    0 returned 100%
       20:  119:    if(testState.coins == state->coins++)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  120:    {
       20:  121:        printf("State Coin Test passed.\n");
call    0 returned 100%
        -:  122:    }
        -:  123:    else
        -:  124:    {
    #####:  125:        printf("State Coin Test failed.\n");
call    0 never executed
    #####:  126:        failTest = 1;
        -:  127:    }
        -:  128:
        -:  129:
       20:  130:    printf("Previous Hand Count: %d\n", state->handCount[currentPlayer]);
call    0 returned 100%
       20:  131:    printf("Current Hand Count: %d\n", testState.handCount[currentPlayer]);
call    0 returned 100%
        -:  132:
       40:  133:    while(z-1>=0){
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  134:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  135:	z=z-1;
        -:  136:    }
        -:  137:
       20:  138:    return failTest;
        -:  139:}
        -:  140:
function main called 1 returned 100% blocks executed 100%
        1:  141:int main()
        -:  142:{
        -:  143:    // Set up the test harness.
        -:  144:
        1:  145:    srand(time(NULL));
call    0 returned 100%
call    1 returned 100%
        1:  146:    int x, i, testSuiteSuccess = 0, testSuiteFailure = 0, testsRun = 0;
        1:  147:    int seed = 1000; // Perhaps having a set seed would standardize testing, but we need ALL situations tested, even those we don't anticipate.
        1:  148:    int k[10] = { adventurer, smithy, village, baron, great_hall, council_room, salvager, sea_hag, gardens, mine };
        -:  149:    // const char *cards[] = { "curse", "estate", "duchy", "province", "copper", "silver", "gold", "adventurer", "council_room", "feast", "gardens", "mine", "remodel", "smithy", "village", "baron",
        -:  150:    // "great_hall", "minion", "steward", "tribute", "ambassador", "cutpurse", "embargo", "outpost", "salvager", "sea_hag", "treasure_map" };
        1:  151:    int randomCard = 0; //rand() % 10;
        1:  152:    int z = 0;
        1:  153:    int drawnTreasure = rand() % 3;
call    0 returned 100%
        -:  154:
        1:  155:    struct gameState *post = malloc(sizeof(struct gameState));
        -:  156:    int temphand[MAX_HAND];
        1:  157:    initializeGame(2, k, seed, post);
call    0 returned 100%
        -:  158:
      501:  159:    for(i=0; i < MAX_HAND; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  160:    {
      500:  161:        if(i < 2)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  162:        {
        2:  163:           temphand[i] = copper;
        -:  164:        }
        -:  165:        else
        -:  166:        {
      498:  167:            temphand[i] = k[i];
        -:  168:        }
        -:  169:    }
        -:  170:
        1:  171:    printf("Testing Adventurer!\n");
call    0 returned 100%
       21:  172:    for(i=0; i < 20; i++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  173:    {
       20:  174:        x = checkPlayAdventurer(post, 0, randomCard, drawnTreasure, temphand, z);
call    0 returned 100%
       20:  175:        if(x)
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
        -:  176:        {
       12:  177:            printf("One or More Assertion and Gameplay Tests Failed.\n");
call    0 returned 100%
       12:  178:            testSuiteFailure++;
       12:  179:            testsRun++;
        -:  180:        }
        -:  181:        else
        -:  182:        {
        8:  183:            printf("All Assertion and Gameplay Tests Passed!\n");
call    0 returned 100%
        8:  184:            testSuiteSuccess++;
        8:  185:            testsRun++;
        -:  186:        }
        -:  187:    }
        -:  188:
        1:  189:    printf("Successes / Tests Run: %d / %d\n", testSuiteSuccess, testsRun);
call    0 returned 100%
        1:  190:    printf("Failures / Tests Run: %d / %d\n", testSuiteFailure, testsRun);
call    0 returned 100%
        -:  191:
        1:  192:    free(post);
        1:  193:    return 0;
        -:  194:}
File 'cardTest2.c'
Lines executed:84.43% of 122
cardTest2.c:creating 'cardTest2.c.gcov'

        -:    0:Source:cardTest2.c
        -:    0:Graph:cardTest2.gcno
        -:    0:Data:cardTest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Andrew M. Calhoun
        -:    2:// CARD TEST - ASSIGNMENT 3
        -:    3:// CardTest2.c
        -:    4:// Unit Test for card function - SMITHY.
        -:    5:
        -:    6:// cardtest2: cardtest2.c dominion.o rngs.o
        -:    7://       gcc -o cardtest2 -g  cardtest2.c dominion.o rngs.o $(CFLAGS)
        -:    8:
        -:    9:
        -:   10:#include "dominion.h"
        -:   11:#include "dominion_helpers.h"
        -:   12:#include "rngs.h"
        -:   13:#include <string.h>
        -:   14:#include <stdio.h>
        -:   15:#include <assert.h>
        -:   16:#include <time.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <math.h>
        -:   19:#include <stdlib.h>
        -:   20:
        -:   21:#define DEBUG 0
        -:   22:#define NOISY_TEST 1
        -:   23:#define TESTCARD "smithy"
        -:   24:
        -:   25:/*
        -:   26:
        -:   27:int playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:   28:{
        -:   29:
        -:   30:    int i;
        -:   31:
        -:   32://+3 Cards  *** REFACTOR changes i++ to ++i, breaks the intent of the card.
        -:   33:      for (i = 0; i < 3; ++i)
        -:   34:	{
        -:   35:	  drawCard(currentPlayer, state);
        -:   36:	}
        -:   37:      //discard card from hand
        -:   38:      discardCard(handPos, currentPlayer, state, 0);
        -:   39:      return 0;
        -:   40:}
        -:   41:
        -:   42:*/
        -:   43:
        1:   44:int main()
        -:   45:{
        1:   46:    int i, seed = 65535, numPlayer = 2, thisPlayer, index=0, allTestsPassed = 0, smithyFail = 0;
        1:   47:    int k[10] = {adventurer, smithy, great_hall, council_room, salvager, gardens, mine, remodel, village, ambassador };
        -:   48:
        -:   49:    // Checking for victory conditions:
        -:   50:    int victoryPoints; // kCardCount;
        -:   51:    int points[13];
        -:   52:
        -:   53:    struct gameState state, testState;
        -:   54:    //int count;
        -:   55:
        -:   56:
        1:   57:    memset(&state, 0, sizeof(struct gameState)); // Ensure we have a clean slate.
        1:   58:    initializeGame(numPlayer, k, seed, &testState);
        -:   59:
        1:   60:    memcpy(&state, &testState, sizeof(struct gameState));
        -:   61:
        -:   62://    // DEBUG CHECK: MAKE SURE THAT ALL THINGS ARE IN PROPER ORDER!
        -:   63://    printf("Supply of Estates: %d\n", testState.supplyCount[estate]);
        -:   64://    assert(testState.supplyCount[estate] == 8);
        -:   65://    printf("Supply of Duchies: %d\n", testState.supplyCount[duchy]);
        -:   66://    assert(testState.supplyCount[duchy] == 8);
        -:   67://    printf("Supply of Provinces: %d\n", testState.supplyCount[province]);
        -:   68://    assert(testState.supplyCount[province] == 8);
        -:   69:
        -:   70:    // Treasure cards are variable, cards that assist in victory conditions such as the Land Parcels, Great Hall and Gardens should be 8, all Kingdom Cards should be 10. For the
        -:   71:    // purposes of this test, we need to make sure that the supply of land parcels is proper.
        -:   72:
        1:   73:    printf("Testing Smithy!\n");
        -:   74:
        1:   75:    victoryPoints = testState.supplyCount[estate];
        1:   76:    points[index] = victoryPoints;
        1:   77:    index++;
        -:   78:
        -:   79://    printf("Total Estate Victory Points: %d\n", victoryPoints);
        1:   80:    assert(victoryPoints == 8);
        -:   81:
        -:   82:
        1:   83:    victoryPoints = testState.supplyCount[duchy] * 3;
        1:   84:    points[index] = victoryPoints;
        1:   85:    index++;
        -:   86:
        -:   87:   // printf("Total Duchy Victory Points: %d\n", victoryPoints);
        1:   88:    assert(victoryPoints == 24);
        -:   89:
        1:   90:    victoryPoints = testState.supplyCount[province] * 6;
        1:   91:    points[index] = victoryPoints;
        1:   92:    index++;
        -:   93:
        -:   94://    printf("Total Province Victory Points: %d\n", victoryPoints);
        1:   95:    assert(victoryPoints == 48);
        -:   96://    assert(points[0] == 8 && points[1] == 24 && points[2] == 48); // Make sure all the points match up.
        -:   97:
        -:   98://    for(i = 0; i < 10; i++)
        -:   99://    {
        -:  100://        kCardCount = testState.supplyCount[k[i]];
        -:  101://        points[index] = kCardCount;
        -:  102://        index++;
        -:  103://        printf("k[%d] count: %d\n", i, kCardCount);
        -:  104://        if(kCardCount != testState.supplyCount[k[i]]);
        -:  105://        {
        -:  106://            allTestsPassed=0;
        -:  107://        }
        -:  108://    }
        -:  109://    if(!allTestsPassed) printf("Some cards do not have the proper supply. Please see reference materials or restore base game files for proper output.\n");
        -:  110:
        1:  111:    thisPlayer=0;
        1:  112:    printf("Player 1 Test -- GIVING SMITHY");
        -:  113:
        1:  114:    testState.hand[thisPlayer][testState.handCount[thisPlayer]] = smithy;
        1:  115:    testState.handCount[thisPlayer]++;
        1:  116:    if(state.handCount[thisPlayer] + 1 == testState.handCount[thisPlayer])
        -:  117:    {
        1:  118:        printf("Giving Smithy Test Passed.\n");
        -:  119:    }
        -:  120:    else
        -:  121:    {
    #####:  122:        printf("Unable to give Smithy. Aborting.\n\n");
    #####:  123:        allTestsPassed = 0;
    #####:  124:        exit(0);
        -:  125:    }
        -:  126:
        6:  127:    for(i=0; i < testState.deckCount[thisPlayer]; i++)
        -:  128:    {
        5:  129:        printf("Position %d, Card: %d\n", i, testState.deck[thisPlayer][i]);
        -:  130:    }
        -:  131:
        1:  132:    printf("DECK COUNTED\n");
        1:  133:    printf("DISCARD COUNT -- SHOULD BE 0\n");
        -:  134:
        1:  135:    if(testState.discardCount[thisPlayer] == 0)
        -:  136:    {
        1:  137:        printf("Discard Successful. Count successful.\n");
        -:  138:    }
        -:  139:    else
        -:  140:    {
    #####:  141:        printf("Discard Count Unsuccessful.\n");
    #####:  142:        allTestsPassed = 0;
        -:  143:    }
        -:  144:
        -:  145:    // EXPECTED: 1, 4, 1, 4, 1, 13;
        1:  146:    int handCountExpect[] = { 1, 4, 1, 4, 1, 13 }; // 13 is smithy. MAKE SURE IT'S SMITHY!!!!
        1:  147:    assert(testState.hand[thisPlayer][5] == smithy);
        7:  148:    for(i=0; i < testState.handCount[thisPlayer]; i++)
        -:  149:    {
        6:  150:        printf("Position %d, card: %d\n", i, testState.hand[thisPlayer][i]);
        6:  151:        if(handCountExpect[i] != testState.hand[thisPlayer][i]);
        -:  152:        {
        6:  153:            allTestsPassed=0;
        -:  154:        }
        -:  155:    }
        -:  156:
        -:  157:    // Add 3 more cards to deck.
        1:  158:    testState.deck[thisPlayer][testState.deckCount[thisPlayer] ] = gardens; // 10
        1:  159:    testState.deckCount[thisPlayer]++;
        1:  160:    testState.deck[thisPlayer][testState.deckCount[thisPlayer] ] = salvager; // 24
        1:  161:    testState.deckCount[thisPlayer]++;
        1:  162:    testState.deck[thisPlayer][testState.deckCount[thisPlayer] ] = ambassador; // 20
        1:  163:    testState.deckCount[thisPlayer]++;
        -:  164:
        -:  165:    // TEST THE SMITHY
        -:  166:
        1:  167:    printf("Smithy Granted Hand Count: %d\n", testState.handCount[thisPlayer]);
        1:  168:    printf("Pre-Smithy Granted Hand Count: %d\n", state.handCount[thisPlayer]);
        -:  169:
        1:  170:    playSmithy(&testState, thisPlayer, 0);
        -:  171:
        1:  172:    if(testState.handCount[thisPlayer] == state.handCount[thisPlayer] + 4) // Should fail, bug gives only two cards. Test also factors in the fact that Smithy Card is granted.
        -:  173:    {
    #####:  174:        printf("Smithy added 3 cards successfully. Test Passed.\n");
        -:  175:    }
        -:  176:    else
        -:  177:    {
        1:  178:        printf("Smithy did not add expected number of cards.\n");
        1:  179:        printf("Expected Hand Count: %d\n", state.handCount[thisPlayer] + 4);
        1:  180:        printf("Result: %d\n", testState.handCount[thisPlayer]);
        1:  181:        allTestsPassed = 0;
        1:  182:        smithyFail = 1;
        -:  183:    }
        -:  184:
        -:  185:
        1:  186:    printf("Testing Card Discard.\n");
        -:  187:
        1:  188:    for(i=0; i < testState.discardCount[thisPlayer]; i++)
        -:  189:    {
    #####:  190:        printf("Discard Card: %d\n", testState.discard[thisPlayer][i]);
        -:  191:    }
        -:  192:
        1:  193:    if(testState.deckCount[thisPlayer] == state.deckCount[thisPlayer]) // Should be even again.
        -:  194:    {
        1:  195:        printf("Discard test and check passed.\n");
        -:  196:    }
        -:  197:    else
        -:  198:    {
    #####:  199:        printf("Discard test and check failed.\n");
    #####:  200:        allTestsPassed=0;
        -:  201:    }
        -:  202:
        1:  203:    printf("Checking expected seed state.\n");
        -:  204:
        1:  205:    int seedDeckExpect[] = { 4, 4, 4, 4, 4 };
        6:  206:    for(i=0; i < testState.deckCount[thisPlayer]; i++)
        -:  207:    {
        5:  208:        printf("Position %d Deck Card: %d\n", i, testState.deck[thisPlayer][i]);
        5:  209:       if(seedDeckExpect[i] != testState.deck[thisPlayer][i]) allTestsPassed=0;
        -:  210:    }
        -:  211:
        1:  212:    if(allTestsPassed) printf("Seed Deck Test Passed. State is not corrupted.\n");
        1:  213:    else printf("Test failed. Please check code or revise seed.\n");
        -:  214:
        1:  215:    printf("Checking hand and seed state.\n");
        -:  216:
        1:  217:    int seedHandExpect[] = {10, 4, 1, 4, 1, 13, 20, 24};
        1:  218:    int seedNameExpect[] = { gardens, copper, estate, copper, estate, smithy, ambassador, salvager };
        9:  219:    for(i=0; i < testState.handCount[thisPlayer]; i++)
        -:  220:    {
        8:  221:        if(seedHandExpect[i] != testState.hand[thisPlayer][i])
        -:  222:        {
    #####:  223:            allTestsPassed = 0;
        -:  224:        }
        8:  225:        if(seedHandExpect[i] != seedNameExpect[i])
        -:  226:        {
    #####:  227:            allTestsPassed = 0;
        -:  228:        }
        -:  229:        //printf("Position %d Hand Card: %d\n", i, testState.hand[thisPlayer][i]);
        -:  230:    }
        -:  231:
        1:  232:    printf("Test Passed.\n");
        -:  233:
        1:  234:    thisPlayer = 1;
        -:  235:    // Do the tests again.
        1:  236:    printf("\nPlayer 2 Tests ----- Making sure everything looks good for their turn.\n\n");
        -:  237:
        1:  238:    int copperCount = 0;
        1:  239:    int estateCount = 0;
        -:  240:
        1:  241:    printf("DECK RECOUNT\n");
       11:  242:    for(i = 0; i < testState.deckCount[thisPlayer]; i++)
        -:  243:    {
       10:  244:        printf("Position %d, Card: %d\n", i, testState.deck[thisPlayer][i]);
       10:  245:        if(testState.deck[thisPlayer][i] == copper)
        -:  246:        {
        7:  247:            copperCount++;
        -:  248:        }
       10:  249:        if(testState.deck[thisPlayer][i] == estate)
        -:  250:        {
        3:  251:            estateCount++;
        -:  252:        }
        -:  253:    }
        -:  254:
        1:  255:    if(copperCount != 7)
        -:  256:    {
    #####:  257:        printf("Improper copper amount. Should be 7. Result: %d\n", copperCount);
    #####:  258:        allTestsPassed = 0;
        -:  259:    }
        1:  260:    if(estateCount != 3)
        -:  261:    {
    #####:  262:        printf("Improper estate amount. Should be 3. Result: %d\n", estateCount);
    #####:  263:        allTestsPassed = 0;
        -:  264:    }
        -:  265:
        -:  266:
        1:  267:    printf("Player has 10 card count Test.\n");
        -:  268:
        1:  269:    if(testState.deckCount[thisPlayer] == 10)
        -:  270:    {
        1:  271:        printf("Player has proper number of cards.\n");
        -:  272:    }
        -:  273:    else
        -:  274:    {
    #####:  275:        printf("Player has improper number of cards. Should have 10.\nPlayer Has: %d\n", testState.deckCount[thisPlayer]);
    #####:  276:        allTestsPassed = 0;
        -:  277:    }
        -:  278:
        1:  279:    testState.hand[thisPlayer][testState.handCount[thisPlayer]] = smithy;
        1:  280:    testState.handCount[thisPlayer]++;
        1:  281:    if(state.handCount[thisPlayer] + 1 == testState.handCount[thisPlayer])
        -:  282:    {
        1:  283:        printf("Smithy properly granted to player and player card count incremented.\n");
        -:  284:    }
        -:  285:    else
        -:  286:    {
    #####:  287:        printf("Smithy was either improperly granted or card count not incremented.\n");
    #####:  288:        allTestsPassed=0;
        -:  289:    }
        -:  290:
        -:  291:    // Ensure the victory card count is the same.
        -:  292:
        1:  293:    assert(testState.supplyCount[estate] == 8);
        1:  294:    assert(testState.supplyCount[estate] == 8);
        1:  295:    assert(testState.supplyCount[estate] == 8);
        1:  296:    assert(points[0] == 8);
        1:  297:    assert(points[1] == 24);
        1:  298:    assert(points[2] == 48);
        -:  299:
        1:  300:    if(allTestsPassed) printf("No state changes, all tests passed.\n\n");
        1:  301:    else printf("One or more tests failed. Please review outputs and revise code.\n");
        1:  302:    if(smithyFail)
        -:  303:    {
        1:  304:        printf("Smithy card did not work properly. Please revise code.\n");
        1:  305:        printf("Smithy gave: %d\n", testState.handCount[0]);
        1:  306:        printf("Expected: %d\n", state.handCount[0] + 4);
        -:  307:    }
        -:  308:
        1:  309:    return 0;
        -:  310:}
File 'cardTest2.c'
Lines executed:84.43% of 122
Branches executed:100.00% of 64
Taken at least once:60.94% of 64
Calls executed:59.26% of 54
cardTest2.c:creating 'cardTest2.c.gcov'

        -:    0:Source:cardTest1.c
        -:    0:Graph:cardTest1.gcno
        -:    0:Data:cardTest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Andrew M. Calhoun
        -:    2:// UNIT TEST - ASSIGNMENT 3
        -:    3:// unitTest1.c
        -:    4:// Unit Test for card function -- ADVENTURER.
        -:    5:// cardtest1: cardtest1.c dominion.o rngs.o
        -:    6://       gcc -o cardtest1 -g  cardtest1.c dominion.o rngs.o $(CFLAGS)
        -:    7:
        -:    8:
        -:    9:
        -:   10:#include "dominion.h"
        -:   11:#include "dominion_helpers.h"
        -:   12:#include "rngs.h"
        -:   13:#include <string.h>
        -:   14:#include <stdio.h>
        -:   15:#include <assert.h>
        -:   16:#include <time.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <math.h>
        -:   19:#include <stdlib.h>
        -:   20:
        -:   21:#define DEBUG 0
        -:   22:#define NOISY_TEST 1
        -:   23:#define TESTCARD "adventurer"
        -:   24:
        -:   25:/*
        -:   26:
        -:   27:int playAdventurer(struct gameState *state, int currentPlayer, int cardDrawn, int drawntreasure, int temphand[], int z)
        -:   28:{
        -:   29:
        -:   30:      while(drawntreasure<2){
        -:   31:	if (state->deckCount[currentPlayer] <=1)
        -:   32:        {//if the deck is empty we need to shuffle discard and add to deck *** REFACTOR to <= will cause additional shuffling.
        -:   33:	  shuffle(currentPlayer, state);
        -:   34:        }
        -:   35:        drawCard(currentPlayer, state);
        -:   36:        cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
        -:   37:        if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        -:   38:	  drawntreasure+=2; // The adventurer should not make off with your treasure. Originally had this put as --, but it actually caused the game to freeze. Opted to give the player more coins. Changes seeded outcomes.
        -:   39:	else{
        -:   40:	  temphand[z]=cardDrawn;
        -:   41:	  state->handCount[currentPlayer]++; //this should just remove the top card (the most recently drawn one).
        -:   42:	  z++;
        -:   43:	}
        -:   44:      }
        -:   45:      while(z-1>=0){
        -:   46:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
        -:   47:	z=z-1;
        -:   48:      }
        -:   49:      return 0;
        -:   50:}
        -:   51:
        -:   52:*/
        -:   53:
function checkPlayAdventurer called 20 returned 100% blocks executed 81%
       20:   54:int checkPlayAdventurer(struct gameState *state, int currentPlayer, int cardDrawn, int drawnTreasure, int temphand[], int z)
        -:   55:{
       20:   56:    int preDraw, failTest = 0;
        -:   57:    // int x;
        -:   58:    struct gameState testState;
       20:   59:    memcpy(&testState, state, sizeof(struct gameState));
        -:   60:
       20:   61:    printf("\nChecking Drawn Treasure.\nDrawn Treasure: %d\n", drawnTreasure);
call    0 returned 100%
        -:   62:
       20:   63:    printf("Initiating randomized deckCount: 1-5\n");
call    0 returned 100%
       20:   64:    state->deckCount[currentPlayer] = rand() % 3;
call    0 returned 100%
        -:   65:
       20:   66:    printf("Deck Count: %d\n", state->deckCount[currentPlayer]);
call    0 returned 100%
        -:   67:
       20:   68:    preDraw = drawnTreasure;
        -:   69:
       52:   70:    while(drawnTreasure < 2)   // less than two drawn treasure...
branch  0 taken 63%
branch  1 taken 38% (fallthrough)
        -:   71:    {
       20:   72:        if(state->deckCount[currentPlayer] <= 1)
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
        -:   73:        {
       12:   74:            shuffle(currentPlayer, &testState);
call    0 returned 100%
       12:   75:            if(state->deckCount[currentPlayer] == 0)
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
        -:   76:            {
        7:   77:                printf("Deck shuffled at 0 properly. Test Passed.\n");
call    0 returned 100%
        -:   78:            }
        -:   79:            else
        -:   80:            {
        5:   81:                printf("Deck shuffled at 1. Test Failed.\n");
call    0 returned 100%
        5:   82:                failTest = 1;
        -:   83:            }
       12:   84:            drawCard(currentPlayer, &testState);
call    0 returned 100%
       12:   85:            cardDrawn = testState.hand[currentPlayer][state->handCount[currentPlayer]-1];
       24:   86:            if(cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:   87:            {
       12:   88:                drawnTreasure+=2;   // will add too much treasure. Will always fail.
       12:   89:                if(preDraw++ == drawnTreasure)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   90:                {
    #####:   91:                    printf("Treasure Draw Check Passed");
call    0 never executed
        -:   92:                }
        -:   93:                else
        -:   94:                {
       12:   95:                    printf("Treasure Draw Check Failed.");
call    0 returned 100%
       12:   96:                    failTest = 1;
        -:   97:                }
        -:   98:
        -:   99:
        -:  100:            }
        -:  101:            else
        -:  102:            {
    #####:  103:                temphand[z] = cardDrawn;
    #####:  104:                testState.handCount[currentPlayer]++;
    #####:  105:                z++;
        -:  106:            }
        -:  107:
        -:  108:        }
        -:  109:
        -:  110:        else
        -:  111:        {
        8:  112:            printf("No shuffle. Test Passed.\n");
call    0 returned 100%
        8:  113:            break;
        -:  114:            // shuffled = 0;
        -:  115:        }
        -:  116:    }
        -:  117:
       20:  118:    printf("Testing Coins. Should only add 1\n\n");
call    0 returned 100%
       20:  119:    if(testState.coins == state->coins++)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  120:    {
       20:  121:        printf("State Coin Test passed.\n");
call    0 returned 100%
        -:  122:    }
        -:  123:    else
        -:  124:    {
    #####:  125:        printf("State Coin Test failed.\n");
call    0 never executed
    #####:  126:        failTest = 1;
        -:  127:    }
        -:  128:
        -:  129:
       20:  130:    printf("Previous Hand Count: %d\n", state->handCount[currentPlayer]);
call    0 returned 100%
       20:  131:    printf("Current Hand Count: %d\n", testState.handCount[currentPlayer]);
call    0 returned 100%
        -:  132:
       40:  133:    while(z-1>=0){
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  134:	state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  135:	z=z-1;
        -:  136:    }
        -:  137:
       20:  138:    return failTest;
        -:  139:}
        -:  140:
function main called 1 returned 100% blocks executed 100%
        1:  141:int main()
        -:  142:{
        -:  143:    // Set up the test harness.
        -:  144:
        1:  145:    srand(time(NULL));
call    0 returned 100%
call    1 returned 100%
        1:  146:    int x, i, testSuiteSuccess = 0, testSuiteFailure = 0, testsRun = 0;
        1:  147:    int seed = 1000; // Perhaps having a set seed would standardize testing, but we need ALL situations tested, even those we don't anticipate.
        1:  148:    int k[10] = { adventurer, smithy, village, baron, great_hall, council_room, salvager, sea_hag, gardens, mine };
        -:  149:    // const char *cards[] = { "curse", "estate", "duchy", "province", "copper", "silver", "gold", "adventurer", "council_room", "feast", "gardens", "mine", "remodel", "smithy", "village", "baron",
        -:  150:    // "great_hall", "minion", "steward", "tribute", "ambassador", "cutpurse", "embargo", "outpost", "salvager", "sea_hag", "treasure_map" };
        1:  151:    int randomCard = 0; //rand() % 10;
        1:  152:    int z = 0;
        1:  153:    int drawnTreasure = rand() % 3;
call    0 returned 100%
        -:  154:
        1:  155:    struct gameState *post = malloc(sizeof(struct gameState));
        -:  156:    int temphand[MAX_HAND];
        1:  157:    initializeGame(2, k, seed, post);
call    0 returned 100%
        -:  158:
      501:  159:    for(i=0; i < MAX_HAND; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  160:    {
      500:  161:        if(i < 2)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  162:        {
        2:  163:           temphand[i] = copper;
        -:  164:        }
        -:  165:        else
        -:  166:        {
      498:  167:            temphand[i] = k[i];
        -:  168:        }
        -:  169:    }
        -:  170:
        1:  171:    printf("Testing Adventurer!\n");
call    0 returned 100%
       21:  172:    for(i=0; i < 20; i++)
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  173:    {
       20:  174:        x = checkPlayAdventurer(post, 0, randomCard, drawnTreasure, temphand, z);
call    0 returned 100%
       20:  175:        if(x)
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
        -:  176:        {
       12:  177:            printf("One or More Assertion and Gameplay Tests Failed.\n");
call    0 returned 100%
       12:  178:            testSuiteFailure++;
       12:  179:            testsRun++;
        -:  180:        }
        -:  181:        else
        -:  182:        {
        8:  183:            printf("All Assertion and Gameplay Tests Passed!\n");
call    0 returned 100%
        8:  184:            testSuiteSuccess++;
        8:  185:            testsRun++;
        -:  186:        }
        -:  187:    }
        -:  188:
        1:  189:    printf("Successes / Tests Run: %d / %d\n", testSuiteSuccess, testsRun);
call    0 returned 100%
        1:  190:    printf("Failures / Tests Run: %d / %d\n", testSuiteFailure, testsRun);
call    0 returned 100%
        -:  191:
        1:  192:    free(post);
        1:  193:    return 0;
        -:  194:}
File 'cardTest3.c'
Lines executed:73.17% of 41
cardTest3.c:creating 'cardTest3.c.gcov'

        -:    0:Source:cardTest3.c
        -:    0:Graph:cardTest3.gcno
        -:    0:Data:cardTest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Andrew M. Calhoun
        -:    2:// CARD TEST - ASSIGNMENT 3
        -:    3:// cardTest3.c
        -:    4:// Unit Test for card function - village.
        -:    5:
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:#include "rngs.h"
        -:    9:#include <string.h>
        -:   10:#include <stdio.h>
        -:   11:#include <assert.h>
        -:   12:#include <time.h>
        -:   13:#include <stdlib.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:
        -:   17:#define DEBUG 0
        -:   18:#define NOISY_TEST 1
        -:   19:#define TESTCARD "village"
        -:   20:
        -:   21:/*
        -:   22:int playVillage(struct gameState *state, int currentPlayer, int handPos)
        -:   23:{
        -:   24:      //+1 Card
        -:   25:      drawCard(currentPlayer, state);
        -:   26:
        -:   27:      //+2 Actions
        -:   28:      state->numActions = state->numActions + 2;
        -:   29:
        -:   30:      //discard played card from hand
        -:   31:      // discardCard(handPos, currentPlayer, state, 0);
        -:   32:      return 0;
        -:   33:}
        -:   34:*/
        -:   35:
        1:   36:int main()
        -:   37:{
        1:   38:	int i, thisPlayer, seed = 65535, numPlayer = 2, kCardCount, allTestsPassed = 1;
        1:   39:	int k[10] = {adventurer, smithy, great_hall, council_room, salvager, gardens, mine, remodel, village, ambassador };
        -:   40:	struct gameState state, testState;
        -:   41:
        -:   42:
        -:   43:   // memset(&state, 0, sizeof(struct gameState)); // Ensure we have a clean slate.
        1:   44:    initializeGame(numPlayer, k, seed, &testState);
        -:   45:
        1:   46:    memcpy(&state, &testState, sizeof(struct gameState));
        -:   47:
        -:   48:
        1:   49:    thisPlayer = 0;
        1:   50:	playVillage(&testState, thisPlayer, 0);
        -:   51:
        -:   52:
        1:   53:    printf("TEST #1: Assert that each victory card has 8 cards in the supply, if not, abort program.\nPotential issue is base game is modified. Please reload base files if game has been altered.");
        1:   54:	assert(testState.supplyCount[estate] == 8);
        1:   55:	assert(testState.supplyCount[duchy] == 8);
        1:   56:	assert(testState.supplyCount[province] == 8);
        -:   57:
        -:   58:	// Make sure kingdom cards are properly supplied.
       11:   59:	for(i = 0; i < 10; i++)
        -:   60:	{
       10:   61:		kCardCount = testState.supplyCount[k[i]];
       10:   62:		printf("k[%d] count: %d\n", i, kCardCount);
        -:   63:		// assert(kCardCount = testState.supplyCount[k[i]]);
       10:   64:		if(kCardCount != testState.supplyCount[k[i]])
        -:   65:        {
    #####:   66:            allTestsPassed = 0;
        -:   67:        }
        -:   68:	}
        -:   69:
        1:   70:	if(allTestsPassed)
        1:   71:        printf("Kingdom Card Supplies All Correct\n");
        -:   72:    else
    #####:   73:        printf("Incorrect number of kingdom cards. Please correct or reload base game files.\n");
        -:   74:
        -:   75:
        1:   76:	printf("TEST #2: Testing Num Action and Card Draw Increases...\n");
        1:   77:	if(testState.handCount[thisPlayer] == state.handCount[thisPlayer] + 1)
        -:   78:    {
        1:   79:        printf("TEST #2: Cards Drawn Properly Increased.\n");
        -:   80:    }
        -:   81:	// assert(testState.handCount[thisPlayer] == state.handCount[thisPlayer] + 1);
        -:   82:	else
        -:   83:    {
    #####:   84:        printf("TEST #2: Cards Drawn Not Properly Increased.\n");
    #####:   85:        printf("Expected: %d\n", state.handCount[thisPlayer] +1);
    #####:   86:        printf("Result: %d\n\n", testState.handCount[thisPlayer]);
    #####:   87:        allTestsPassed = 0;
        -:   88:    }
        -:   89:
        1:   90:    if(testState.numActions == state.numActions + 2)
        -:   91:    {
        1:   92:        printf("TEST #2: Number of actions are properly increased.\n");
        -:   93:    }
        -:   94:    else
        -:   95:    {
    #####:   96:        printf("TEST #2: Number of Actions not Properly Increased.\n");
    #####:   97:        printf("Expected: %d\n", state.numActions + 2);
    #####:   98:        printf("Result: %d\n\n", testState.numActions);
    #####:   99:        allTestsPassed = 0;
        -:  100:    }
        -:  101:
        -:  102:	// assert(testState.numActions == state.numActions + 2);
        -:  103:
        1:  104:	printf("TEST #3: Discard Test\n");
        -:  105:
        1:  106:	if(testState.discardCount[thisPlayer] == state.discardCount[thisPlayer] + 1)
        -:  107:    {
    #####:  108:        printf("Test #3: Discard Test Passed.\n\n");
        -:  109:    }
        -:  110:    else
        -:  111:    {
        1:  112:        printf("TEST #3: Discard Test Failed!\nExpected: %d\n", state.discardCount[thisPlayer] + 1);
        1:  113:        printf("Result: %d\n\n", testState.discardCount[thisPlayer]);
        1:  114:        allTestsPassed = 0;
        -:  115:    }
        -:  116:
        1:  117:    if(allTestsPassed) printf("All tests passed!");
        1:  118:    else printf("One or more tests failed, please review results and revise code.\n\n");
        -:  119:
        1:  120:	return 0;
        -:  121:
        -:  122:}
File 'cardTest3.c'
Lines executed:73.17% of 41
Branches executed:100.00% of 20
Taken at least once:55.00% of 20
Calls executed:50.00% of 24
cardTest3.c:creating 'cardTest3.c.gcov'

        -:    0:Source:cardTest3.c
        -:    0:Graph:cardTest3.gcno
        -:    0:Data:cardTest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Andrew M. Calhoun
        -:    2:// CARD TEST - ASSIGNMENT 3
        -:    3:// cardTest3.c
        -:    4:// Unit Test for card function - village.
        -:    5:
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:#include "rngs.h"
        -:    9:#include <string.h>
        -:   10:#include <stdio.h>
        -:   11:#include <assert.h>
        -:   12:#include <time.h>
        -:   13:#include <stdlib.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:
        -:   17:#define DEBUG 0
        -:   18:#define NOISY_TEST 1
        -:   19:#define TESTCARD "village"
        -:   20:
        -:   21:/*
        -:   22:int playVillage(struct gameState *state, int currentPlayer, int handPos)
        -:   23:{
        -:   24:      //+1 Card
        -:   25:      drawCard(currentPlayer, state);
        -:   26:
        -:   27:      //+2 Actions
        -:   28:      state->numActions = state->numActions + 2;
        -:   29:
        -:   30:      //discard played card from hand
        -:   31:      // discardCard(handPos, currentPlayer, state, 0);
        -:   32:      return 0;
        -:   33:}
        -:   34:*/
        -:   35:
function main called 1 returned 100% blocks executed 63%
        1:   36:int main()
        -:   37:{
        1:   38:	int i, thisPlayer, seed = 65535, numPlayer = 2, kCardCount, allTestsPassed = 1;
        1:   39:	int k[10] = {adventurer, smithy, great_hall, council_room, salvager, gardens, mine, remodel, village, ambassador };
        -:   40:	struct gameState state, testState;
        -:   41:
        -:   42:
        -:   43:   // memset(&state, 0, sizeof(struct gameState)); // Ensure we have a clean slate.
        1:   44:    initializeGame(numPlayer, k, seed, &testState);
call    0 returned 100%
        -:   45:
        1:   46:    memcpy(&state, &testState, sizeof(struct gameState));
        -:   47:
        -:   48:
        1:   49:    thisPlayer = 0;
        1:   50:	playVillage(&testState, thisPlayer, 0);
call    0 returned 100%
        -:   51:
        -:   52:
        1:   53:    printf("TEST #1: Assert that each victory card has 8 cards in the supply, if not, abort program.\nPotential issue is base game is modified. Please reload base files if game has been altered.");
call    0 returned 100%
        1:   54:	assert(testState.supplyCount[estate] == 8);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        1:   55:	assert(testState.supplyCount[duchy] == 8);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        1:   56:	assert(testState.supplyCount[province] == 8);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   57:
        -:   58:	// Make sure kingdom cards are properly supplied.
       11:   59:	for(i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:	{
       10:   61:		kCardCount = testState.supplyCount[k[i]];
       10:   62:		printf("k[%d] count: %d\n", i, kCardCount);
call    0 returned 100%
        -:   63:		// assert(kCardCount = testState.supplyCount[k[i]]);
       10:   64:		if(kCardCount != testState.supplyCount[k[i]])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   65:        {
    #####:   66:            allTestsPassed = 0;
        -:   67:        }
        -:   68:	}
        -:   69:
        1:   70:	if(allTestsPassed)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   71:        printf("Kingdom Card Supplies All Correct\n");
call    0 returned 100%
        -:   72:    else
    #####:   73:        printf("Incorrect number of kingdom cards. Please correct or reload base game files.\n");
call    0 never executed
        -:   74:
        -:   75:
        1:   76:	printf("TEST #2: Testing Num Action and Card Draw Increases...\n");
call    0 returned 100%
        1:   77:	if(testState.handCount[thisPlayer] == state.handCount[thisPlayer] + 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   78:    {
        1:   79:        printf("TEST #2: Cards Drawn Properly Increased.\n");
call    0 returned 100%
        -:   80:    }
        -:   81:	// assert(testState.handCount[thisPlayer] == state.handCount[thisPlayer] + 1);
        -:   82:	else
        -:   83:    {
    #####:   84:        printf("TEST #2: Cards Drawn Not Properly Increased.\n");
call    0 never executed
    #####:   85:        printf("Expected: %d\n", state.handCount[thisPlayer] +1);
call    0 never executed
    #####:   86:        printf("Result: %d\n\n", testState.handCount[thisPlayer]);
call    0 never executed
    #####:   87:        allTestsPassed = 0;
        -:   88:    }
        -:   89:
        1:   90:    if(testState.numActions == state.numActions + 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   91:    {
        1:   92:        printf("TEST #2: Number of actions are properly increased.\n");
call    0 returned 100%
        -:   93:    }
        -:   94:    else
        -:   95:    {
    #####:   96:        printf("TEST #2: Number of Actions not Properly Increased.\n");
call    0 never executed
    #####:   97:        printf("Expected: %d\n", state.numActions + 2);
call    0 never executed
    #####:   98:        printf("Result: %d\n\n", testState.numActions);
call    0 never executed
    #####:   99:        allTestsPassed = 0;
        -:  100:    }
        -:  101:
        -:  102:	// assert(testState.numActions == state.numActions + 2);
        -:  103:
        1:  104:	printf("TEST #3: Discard Test\n");
call    0 returned 100%
        -:  105:
        1:  106:	if(testState.discardCount[thisPlayer] == state.discardCount[thisPlayer] + 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  107:    {
    #####:  108:        printf("Test #3: Discard Test Passed.\n\n");
call    0 never executed
        -:  109:    }
        -:  110:    else
        -:  111:    {
        1:  112:        printf("TEST #3: Discard Test Failed!\nExpected: %d\n", state.discardCount[thisPlayer] + 1);
call    0 returned 100%
        1:  113:        printf("Result: %d\n\n", testState.discardCount[thisPlayer]);
call    0 returned 100%
        1:  114:        allTestsPassed = 0;
        -:  115:    }
        -:  116:
        1:  117:    if(allTestsPassed) printf("All tests passed!");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        1:  118:    else printf("One or more tests failed, please review results and revise code.\n\n");
call    0 returned 100%
        -:  119:
        1:  120:	return 0;
        -:  121:
        -:  122:}
File 'cardTest4.c'
Lines executed:79.79% of 94
cardTest4.c:creating 'cardTest4.c.gcov'

        -:    0:Source:cardTest4.c
        -:    0:Graph:cardTest4.gcno
        -:    0:Data:cardTest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Andrew M. Calhoun
        -:    2:// CARD TEST - ASSIGNMENT 3
        -:    3:// CardTest4.c
        -:    4:// Unit Test for card function - MINION.
        -:    5:
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:#include "rngs.h"
        -:    9:#include <string.h>
        -:   10:#include <stdio.h>
        -:   11:#include <assert.h>
        -:   12:#include <time.h>
        -:   13:#include <stdlib.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:#include <string.h>
        -:   17:
        -:   18:#define DEBUG 0
        -:   19:#define NOISY_TEST 1
        -:   20:#define TESTCARD "minion"
        -:   21:
        -:   22:/*-------------------------------
        -:   23:// PLAY MINION
        -:   24://-------------------------------
        -:   25:
        -:   26:int playMinion(struct gameState *state, int choice1, int choice2, int currentPlayer, int handPos)
        -:   27:{
        -:   28:
        -:   29:    int i, j;
        -:   30:
        -:   31:
        -:   32:      //+1 action
        -:   33:      state->numActions--;
        -:   34:
        -:   35:      //discard card from hand
        -:   36:      discardCard(handPos, currentPlayer, state, 0);
        -:   37:
        -:   38:      if (choice1)		//+2 coins *** REFACTORED: -2 coins.
        -:   39:	{
        -:   40:	  state->coins = state->coins - 2;
        -:   41:	}
        -:   42:
        -:   43:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:   44:	{
        -:   45:
        -:   46://	  //discard hand ** COMMENTED OUT FOR REFACTORING
        -:   47://	  while(numHandCards(state) > 0)
        -:   48://	    {
        -:   49://	      discardCard(handPos, currentPlayer, state, 0);
        -:   50://	    }
        -:   51:
        -:   52:	  //draw 4 *** REFACTORED TO DRAW 3
        -:   53:	  for (i = 0; i < 3; i++)
        -:   54:	    {
        -:   55:	      drawCard(currentPlayer, state);
        -:   56:	    }
        -:   57:
        -:   58:	  //other players discard hand and redraw if hand size > 4 *** REFACTOR: They not only get to keep their cards, they get 3 MORE!
        -:   59:	  for (i = 0; i < state->numPlayers; i++)
        -:   60:	    {
        -:   61:	      if (i != currentPlayer)
        -:   62:		{
        -:   63:		  if ( state->handCount[i] > 4 )
        -:   64:		    {
        -:   65:		    //  //discard hand
        -:   66:		    //  while( state->handCount[i] > 0 )
        -:   67:			// {
        -:   68:			//  discardCard(handPos, i, state, 0);
        -:   69:			// }
        -:   70:
        -:   71:		      //draw 4 ** REFACTOR: 3
        -:   72:		      for (j = 0; j < 3; j++)
        -:   73:			{
        -:   74:			  drawCard(i, state);
        -:   75:			}
        -:   76:		    }
        -:   77:		}
        -:   78:	    }
        -:   79:
        -:   80:	}
        -:   81:      return 0;
        -:   82:
        -:   83:}
        -:   84:
        -:   85:*/
        -:   86:
        1:   87:int main()
        -:   88:{
        -:   89:    // The minion card has been changed drastically, thus it should fail on most accounts -- tests will find failure points and point them out.
        -:   90:
        1:   91:   int i, thisPlayer, handPos = 0, seed = 65535, numPlayer = 2, kCardCount, choice1, choice2, allTestsPassed = 1;
        1:   92:	int k[10] = {adventurer, smithy, great_hall, council_room, salvager, gardens, mine, remodel, village, ambassador };
        -:   93:	struct gameState state, testState;
        -:   94:
        -:   95:
        -:   96:   // memset(&state, 0, sizeof(struct gameState)); // Ensure we have a clean slate.
        1:   97:    initializeGame(numPlayer, k, seed, &testState);
        -:   98:
        1:   99:    memcpy(&state, &testState, sizeof(struct gameState));
        -:  100:
        1:  101:    testState.coins = 10;
        1:  102:    state.coins = 10;
        1:  103:    testState.numActions = 1;
        -:  104:
        1:  105:    thisPlayer = 0;
        -:  106:    // playMinion(&testState, 0, 0, thisPlayer, 0);
        -:  107:
        -:  108:    // assert(state.supplyCount[duchy] == 8);  // Making sure the supplies are proper, if not,
        -:  109:                                            // please reload original or refactored code
        -:  110://                                            // that does not adjust values...
        -:  111://
        -:  112://    printf("TEST #1: Checking card supplies...\n");
        -:  113://    for(i = 0; i < 26; i++)
        -:  114://    {
        -:  115://        kCardCount = testState.supplyCount[i];
        -:  116://        printf("Card: %d\n", testState.supplyCount[i]);
        -:  117://        assert(testState.supplyCount[i] == kCardCount);
        -:  118://
        -:  119://    }
        -:  120://
        -:  121://    printf("All kingdom and victory cards check out.\n");
        -:  122:
        1:  123:    printf("TEST #1: Minion Card - choice1 = 1, choice 2 = 0\n");
        1:  124:    choice1 = 1;
        1:  125:    choice2 = 0;
        -:  126:
        1:  127:    playMinion(&testState, choice1, choice2, thisPlayer, handPos);
        -:  128:
        1:  129:    printf("Checking to see if action was added...");
        1:  130:    if(testState.numActions == state.numActions + 1)
        -:  131:    {
    #####:  132:        printf("TEST #1: Action Test passed!\n\n");
        -:  133:    }
        -:  134:    else
        -:  135:    {
        1:  136:        printf("TEST #1: Action Test failed!\n");
        1:  137:        printf("Expected: %d\n", state.numActions + 1);
        1:  138:        printf("Result: %d\n\n", testState.numActions);
        1:  139:        allTestsPassed = 0;
        -:  140:       // assert(testState.numActions == state.numActions + 1); // This will break.
        -:  141:    }
        -:  142:
        1:  143:    printf("Checking to see if 2 coins were added...\n");
        1:  144:    if(testState.coins == state.coins + 2)
        -:  145:    {
    #####:  146:        printf("TEST #1: Coin Test passed!\n");
        -:  147:    }
        -:  148:    else
        -:  149:    {
        1:  150:        printf("TEST #1: Coin Test failed!\n That dirty minion stole or forgot to give us coins!\n");
        1:  151:        printf("Expected: %d\n", state.coins + 2);
        1:  152:        printf("Result: %d\n\n", testState.coins);
        1:  153:        allTestsPassed = 0;
        -:  154:    }
        -:  155:
        1:  156:    printf("Discard Count: %d\n", testState.discardCount[thisPlayer]);
        1:  157:    printf("Discards: %d\n", testState.discard[thisPlayer][i]);
        -:  158:
        1:  159:    if(testState.discardCount[thisPlayer] != state.discardCount[thisPlayer])
        -:  160:    {
    #####:  161:        printf("TEST #1: Discard Test Failed.\n");
    #####:  162:        allTestsPassed = 0;
        -:  163:    }
        -:  164:    else
        -:  165:    {
        1:  166:        printf("TEST #1: Discard Test Passed.\n");
        -:  167:    }
        -:  168:
        -:  169:
        1:  170:    printf("TEST #1: Previous Hand Count: %d\n", state.handCount[thisPlayer]);
        1:  171:    printf("TEST #1: Current Hand Count: %d\n", testState.handCount[thisPlayer]);
        -:  172:
        1:  173:    if(state.handCount[thisPlayer] == testState.handCount[thisPlayer] + 1)
        -:  174:    {
        1:  175:        printf("TEST #1: Hand Count Test passed.\n\n");
        -:  176:    }
        -:  177:    else
        -:  178:    {
    #####:  179:        printf("TEST #1: Hand Count Test failed.\n\n");
    #####:  180:        allTestsPassed = 0;
        -:  181:    }
        -:  182:
        1:  183:    printf("Checking to see if other players drew cards. (Should Not if Choice 1 was Picked)\n");
        -:  184:
        2:  185:    for(i=1; i<numPlayer; i++)
        -:  186:    {
        1:  187:        printf("Number of Cards in Hand for Player %d: %d\n", (i+1), testState.handCount[i]);
        1:  188:        if(testState.handCount[i] > state.handCount[i])
        -:  189:        {
    #####:  190:            printf("TEST #1: Player Draw Test failed.\n\n");
    #####:  191:            allTestsPassed = 0;
        -:  192:        }
        -:  193:        else
        -:  194:        {
        1:  195:            printf("TEST #1: Player Draw Test passed.\n\n");
        -:  196:        }
        -:  197:    }
        -:  198:
        1:  199:    printf("Resetting values...\n\n");
        -:  200:
        1:  201:    memcpy(&testState, &state, sizeof(struct gameState));
        -:  202:
        1:  203:    testState.coins = state.coins = 10;
        1:  204:    testState.numActions = state.numActions = 1;
        1:  205:    choice1 = 0;
        1:  206:    choice2 = 1;
        -:  207:
        1:  208:    printf("MINION TEST #2: Checking Choice 2...\n");
        1:  209:    playMinion(&testState, choice1, choice2, thisPlayer, handPos);
        -:  210:
        1:  211:    printf("Checking to see if action was added...\n");
        -:  212:
        1:  213:    if(testState.numActions == state.numActions + 1)
        -:  214:    {
    #####:  215:        printf("TEST #2: Action Test Passed!\n\n");
        -:  216:    }
        -:  217:    else
        -:  218:    {
        1:  219:        printf("TEST #2: Test failed!\n");
        1:  220:        printf("Expected: %d\n", state.numActions + 1);
        1:  221:        printf("Result: %d\n\n", testState.numActions);
        1:  222:        allTestsPassed = 0;
        -:  223:       // assert(testState.numActions == state.numActions + 1); // This will break.
        -:  224:    }
        -:  225:
        -:  226:    // endTurn(&testState);
        -:  227:
        1:  228:    printf("Testing to see if 2 coins were added...\n -- They should not be if choice2 = true\n");
        -:  229:
        1:  230:    if(state.coins == testState.coins)
        -:  231:    {
        1:  232:        printf("TEST #2: Coin Test passed!\n\n");
        -:  233:    }
        -:  234:    else
        -:  235:    {
    #####:  236:        printf("TEST #2: Test failed!\n");
    #####:  237:        printf("Expected: %d\n", state.coins + 2);
    #####:  238:        printf("Result: %d\n\n", testState.coins);
    #####:  239:        allTestsPassed = 0;
        -:  240:    }
        -:  241:
        1:  242:    printf("TEST #2: Checking discard. Should be greater than 0.\n");
        1:  243:    if(testState.discardCount[thisPlayer] > state.discardCount[thisPlayer])
        -:  244:    {
    #####:  245:        printf("TEST #2: Discard Test passed.\n\n");
        -:  246:    }
        -:  247:    else
        -:  248:    {
        1:  249:        printf("TEST #2: Test failed.\n\n");
        1:  250:        allTestsPassed = 0;
        -:  251:    }
        -:  252:
        1:  253:    printf("TEST #2: Checking to see that 4 cards were drawn for player 1\n\n");
        1:  254:    if(testState.handCount[thisPlayer] == state.handCount[thisPlayer] + 4)
        -:  255:    {
    #####:  256:        printf("TEST #2: Draw Test passed!\n\n");
        -:  257:    }
        -:  258:    else
        -:  259:    {
        1:  260:        printf("TEST #2: Draw Test failed!\n");
        1:  261:        printf("Expected: %d\n", state.handCount[thisPlayer] + 4);
        1:  262:        printf("Result: %d\n\n", testState.handCount[thisPlayer]);
        1:  263:        allTestsPassed = 0;
        -:  264:    }
        -:  265:
        1:  266:    printf("TEST #2: Checking Hand Counts for other Players.\n");
        2:  267:    for(i = 1; i < numPlayer; i++)
        -:  268:    {
        1:  269:        printf("Player %d: Hand Count: %d\n", (i+1), testState.handCount[i]);
        1:  270:        if(testState.handCount[i] > 4)
        -:  271:        {
    #####:  272:            printf("TEST #2: Other Player Hand Count Test failed!\n");
    #####:  273:            printf("Expected: 4\n");
    #####:  274:            printf("Result %d\n\n", testState.handCount[1]);
        -:  275:        }
        -:  276:        else
        -:  277:        {
        1:  278:            printf("TEST #2: Other Player Hand Count Test Passed.\n\n");
        1:  279:            printf("Expected: 4\n");
        1:  280:            printf("Result: %d\n", testState.handCount[1]);
        -:  281:
        -:  282:        }
        -:  283:    }
        -:  284:
        -:  285:    // refactored bug should increase number of cards to 6/7, but it does not.
        -:  286:
        -:  287:
        1:  288:    if(allTestsPassed)
        -:  289:    {
    #####:  290:        printf("All tests passed. Function works perfectly!\n");
        -:  291:    }
        -:  292:    else
        -:  293:    {
        1:  294:        printf("One or more tests failed! Please review results and revise code.\n");
        -:  295:    }
        -:  296:
        1:  297:	return 0;
        -:  298:}
File 'cardTest4.c'
Lines executed:79.79% of 94
Branches executed:100.00% of 26
Taken at least once:57.69% of 26
Calls executed:73.21% of 56
cardTest4.c:creating 'cardTest4.c.gcov'

        -:    0:Source:cardTest4.c
        -:    0:Graph:cardTest4.gcno
        -:    0:Data:cardTest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Andrew M. Calhoun
        -:    2:// CARD TEST - ASSIGNMENT 3
        -:    3:// CardTest4.c
        -:    4:// Unit Test for card function - MINION.
        -:    5:
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:#include "rngs.h"
        -:    9:#include <string.h>
        -:   10:#include <stdio.h>
        -:   11:#include <assert.h>
        -:   12:#include <time.h>
        -:   13:#include <stdlib.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:#include <string.h>
        -:   17:
        -:   18:#define DEBUG 0
        -:   19:#define NOISY_TEST 1
        -:   20:#define TESTCARD "minion"
        -:   21:
        -:   22:/*-------------------------------
        -:   23:// PLAY MINION
        -:   24://-------------------------------
        -:   25:
        -:   26:int playMinion(struct gameState *state, int choice1, int choice2, int currentPlayer, int handPos)
        -:   27:{
        -:   28:
        -:   29:    int i, j;
        -:   30:
        -:   31:
        -:   32:      //+1 action
        -:   33:      state->numActions--;
        -:   34:
        -:   35:      //discard card from hand
        -:   36:      discardCard(handPos, currentPlayer, state, 0);
        -:   37:
        -:   38:      if (choice1)		//+2 coins *** REFACTORED: -2 coins.
        -:   39:	{
        -:   40:	  state->coins = state->coins - 2;
        -:   41:	}
        -:   42:
        -:   43:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:   44:	{
        -:   45:
        -:   46://	  //discard hand ** COMMENTED OUT FOR REFACTORING
        -:   47://	  while(numHandCards(state) > 0)
        -:   48://	    {
        -:   49://	      discardCard(handPos, currentPlayer, state, 0);
        -:   50://	    }
        -:   51:
        -:   52:	  //draw 4 *** REFACTORED TO DRAW 3
        -:   53:	  for (i = 0; i < 3; i++)
        -:   54:	    {
        -:   55:	      drawCard(currentPlayer, state);
        -:   56:	    }
        -:   57:
        -:   58:	  //other players discard hand and redraw if hand size > 4 *** REFACTOR: They not only get to keep their cards, they get 3 MORE!
        -:   59:	  for (i = 0; i < state->numPlayers; i++)
        -:   60:	    {
        -:   61:	      if (i != currentPlayer)
        -:   62:		{
        -:   63:		  if ( state->handCount[i] > 4 )
        -:   64:		    {
        -:   65:		    //  //discard hand
        -:   66:		    //  while( state->handCount[i] > 0 )
        -:   67:			// {
        -:   68:			//  discardCard(handPos, i, state, 0);
        -:   69:			// }
        -:   70:
        -:   71:		      //draw 4 ** REFACTOR: 3
        -:   72:		      for (j = 0; j < 3; j++)
        -:   73:			{
        -:   74:			  drawCard(i, state);
        -:   75:			}
        -:   76:		    }
        -:   77:		}
        -:   78:	    }
        -:   79:
        -:   80:	}
        -:   81:      return 0;
        -:   82:
        -:   83:}
        -:   84:
        -:   85:*/
        -:   86:
function main called 1 returned 100% blocks executed 77%
        1:   87:int main()
        -:   88:{
        -:   89:    // The minion card has been changed drastically, thus it should fail on most accounts -- tests will find failure points and point them out.
        -:   90:
        1:   91:   int i, thisPlayer, handPos = 0, seed = 65535, numPlayer = 2, kCardCount, choice1, choice2, allTestsPassed = 1;
        1:   92:	int k[10] = {adventurer, smithy, great_hall, council_room, salvager, gardens, mine, remodel, village, ambassador };
        -:   93:	struct gameState state, testState;
        -:   94:
        -:   95:
        -:   96:   // memset(&state, 0, sizeof(struct gameState)); // Ensure we have a clean slate.
        1:   97:    initializeGame(numPlayer, k, seed, &testState);
call    0 returned 100%
        -:   98:
        1:   99:    memcpy(&state, &testState, sizeof(struct gameState));
        -:  100:
        1:  101:    testState.coins = 10;
        1:  102:    state.coins = 10;
        1:  103:    testState.numActions = 1;
        -:  104:
        1:  105:    thisPlayer = 0;
        -:  106:    // playMinion(&testState, 0, 0, thisPlayer, 0);
        -:  107:
        -:  108:    // assert(state.supplyCount[duchy] == 8);  // Making sure the supplies are proper, if not,
        -:  109:                                            // please reload original or refactored code
        -:  110://                                            // that does not adjust values...
        -:  111://
        -:  112://    printf("TEST #1: Checking card supplies...\n");
        -:  113://    for(i = 0; i < 26; i++)
        -:  114://    {
        -:  115://        kCardCount = testState.supplyCount[i];
        -:  116://        printf("Card: %d\n", testState.supplyCount[i]);
        -:  117://        assert(testState.supplyCount[i] == kCardCount);
        -:  118://
        -:  119://    }
        -:  120://
        -:  121://    printf("All kingdom and victory cards check out.\n");
        -:  122:
        1:  123:    printf("TEST #1: Minion Card - choice1 = 1, choice 2 = 0\n");
call    0 returned 100%
        1:  124:    choice1 = 1;
        1:  125:    choice2 = 0;
        -:  126:
        1:  127:    playMinion(&testState, choice1, choice2, thisPlayer, handPos);
call    0 returned 100%
        -:  128:
        1:  129:    printf("Checking to see if action was added...");
call    0 returned 100%
        1:  130:    if(testState.numActions == state.numActions + 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  131:    {
    #####:  132:        printf("TEST #1: Action Test passed!\n\n");
call    0 never executed
        -:  133:    }
        -:  134:    else
        -:  135:    {
        1:  136:        printf("TEST #1: Action Test failed!\n");
call    0 returned 100%
        1:  137:        printf("Expected: %d\n", state.numActions + 1);
call    0 returned 100%
        1:  138:        printf("Result: %d\n\n", testState.numActions);
call    0 returned 100%
        1:  139:        allTestsPassed = 0;
        -:  140:       // assert(testState.numActions == state.numActions + 1); // This will break.
        -:  141:    }
        -:  142:
        1:  143:    printf("Checking to see if 2 coins were added...\n");
call    0 returned 100%
        1:  144:    if(testState.coins == state.coins + 2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  145:    {
    #####:  146:        printf("TEST #1: Coin Test passed!\n");
call    0 never executed
        -:  147:    }
        -:  148:    else
        -:  149:    {
        1:  150:        printf("TEST #1: Coin Test failed!\n That dirty minion stole or forgot to give us coins!\n");
call    0 returned 100%
        1:  151:        printf("Expected: %d\n", state.coins + 2);
call    0 returned 100%
        1:  152:        printf("Result: %d\n\n", testState.coins);
call    0 returned 100%
        1:  153:        allTestsPassed = 0;
        -:  154:    }
        -:  155:
        1:  156:    printf("Discard Count: %d\n", testState.discardCount[thisPlayer]);
call    0 returned 100%
        1:  157:    printf("Discards: %d\n", testState.discard[thisPlayer][i]);
call    0 returned 100%
        -:  158:
        1:  159:    if(testState.discardCount[thisPlayer] != state.discardCount[thisPlayer])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  160:    {
    #####:  161:        printf("TEST #1: Discard Test Failed.\n");
call    0 never executed
    #####:  162:        allTestsPassed = 0;
        -:  163:    }
        -:  164:    else
        -:  165:    {
        1:  166:        printf("TEST #1: Discard Test Passed.\n");
call    0 returned 100%
        -:  167:    }
        -:  168:
        -:  169:
        1:  170:    printf("TEST #1: Previous Hand Count: %d\n", state.handCount[thisPlayer]);
call    0 returned 100%
        1:  171:    printf("TEST #1: Current Hand Count: %d\n", testState.handCount[thisPlayer]);
call    0 returned 100%
        -:  172:
        1:  173:    if(state.handCount[thisPlayer] == testState.handCount[thisPlayer] + 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  174:    {
        1:  175:        printf("TEST #1: Hand Count Test passed.\n\n");
call    0 returned 100%
        -:  176:    }
        -:  177:    else
        -:  178:    {
    #####:  179:        printf("TEST #1: Hand Count Test failed.\n\n");
call    0 never executed
    #####:  180:        allTestsPassed = 0;
        -:  181:    }
        -:  182:
        1:  183:    printf("Checking to see if other players drew cards. (Should Not if Choice 1 was Picked)\n");
call    0 returned 100%
        -:  184:
        2:  185:    for(i=1; i<numPlayer; i++)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -:  186:    {
        1:  187:        printf("Number of Cards in Hand for Player %d: %d\n", (i+1), testState.handCount[i]);
call    0 returned 100%
        1:  188:        if(testState.handCount[i] > state.handCount[i])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  189:        {
    #####:  190:            printf("TEST #1: Player Draw Test failed.\n\n");
call    0 never executed
    #####:  191:            allTestsPassed = 0;
        -:  192:        }
        -:  193:        else
        -:  194:        {
        1:  195:            printf("TEST #1: Player Draw Test passed.\n\n");
call    0 returned 100%
        -:  196:        }
        -:  197:    }
        -:  198:
        1:  199:    printf("Resetting values...\n\n");
call    0 returned 100%
        -:  200:
        1:  201:    memcpy(&testState, &state, sizeof(struct gameState));
        -:  202:
        1:  203:    testState.coins = state.coins = 10;
        1:  204:    testState.numActions = state.numActions = 1;
        1:  205:    choice1 = 0;
        1:  206:    choice2 = 1;
        -:  207:
        1:  208:    printf("MINION TEST #2: Checking Choice 2...\n");
call    0 returned 100%
        1:  209:    playMinion(&testState, choice1, choice2, thisPlayer, handPos);
call    0 returned 100%
        -:  210:
        1:  211:    printf("Checking to see if action was added...\n");
call    0 returned 100%
        -:  212:
        1:  213:    if(testState.numActions == state.numActions + 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  214:    {
    #####:  215:        printf("TEST #2: Action Test Passed!\n\n");
call    0 never executed
        -:  216:    }
        -:  217:    else
        -:  218:    {
        1:  219:        printf("TEST #2: Test failed!\n");
call    0 returned 100%
        1:  220:        printf("Expected: %d\n", state.numActions + 1);
call    0 returned 100%
        1:  221:        printf("Result: %d\n\n", testState.numActions);
call    0 returned 100%
        1:  222:        allTestsPassed = 0;
        -:  223:       // assert(testState.numActions == state.numActions + 1); // This will break.
        -:  224:    }
        -:  225:
        -:  226:    // endTurn(&testState);
        -:  227:
        1:  228:    printf("Testing to see if 2 coins were added...\n -- They should not be if choice2 = true\n");
call    0 returned 100%
        -:  229:
        1:  230:    if(state.coins == testState.coins)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  231:    {
        1:  232:        printf("TEST #2: Coin Test passed!\n\n");
call    0 returned 100%
        -:  233:    }
        -:  234:    else
        -:  235:    {
    #####:  236:        printf("TEST #2: Test failed!\n");
call    0 never executed
    #####:  237:        printf("Expected: %d\n", state.coins + 2);
call    0 never executed
    #####:  238:        printf("Result: %d\n\n", testState.coins);
call    0 never executed
    #####:  239:        allTestsPassed = 0;
        -:  240:    }
        -:  241:
        1:  242:    printf("TEST #2: Checking discard. Should be greater than 0.\n");
call    0 returned 100%
        1:  243:    if(testState.discardCount[thisPlayer] > state.discardCount[thisPlayer])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  244:    {
    #####:  245:        printf("TEST #2: Discard Test passed.\n\n");
call    0 never executed
        -:  246:    }
        -:  247:    else
        -:  248:    {
        1:  249:        printf("TEST #2: Test failed.\n\n");
call    0 returned 100%
        1:  250:        allTestsPassed = 0;
        -:  251:    }
        -:  252:
        1:  253:    printf("TEST #2: Checking to see that 4 cards were drawn for player 1\n\n");
call    0 returned 100%
        1:  254:    if(testState.handCount[thisPlayer] == state.handCount[thisPlayer] + 4)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  255:    {
    #####:  256:        printf("TEST #2: Draw Test passed!\n\n");
call    0 never executed
        -:  257:    }
        -:  258:    else
        -:  259:    {
        1:  260:        printf("TEST #2: Draw Test failed!\n");
call    0 returned 100%
        1:  261:        printf("Expected: %d\n", state.handCount[thisPlayer] + 4);
call    0 returned 100%
        1:  262:        printf("Result: %d\n\n", testState.handCount[thisPlayer]);
call    0 returned 100%
        1:  263:        allTestsPassed = 0;
        -:  264:    }
        -:  265:
        1:  266:    printf("TEST #2: Checking Hand Counts for other Players.\n");
call    0 returned 100%
        2:  267:    for(i = 1; i < numPlayer; i++)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -:  268:    {
        1:  269:        printf("Player %d: Hand Count: %d\n", (i+1), testState.handCount[i]);
call    0 returned 100%
        1:  270:        if(testState.handCount[i] > 4)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  271:        {
    #####:  272:            printf("TEST #2: Other Player Hand Count Test failed!\n");
call    0 never executed
    #####:  273:            printf("Expected: 4\n");
call    0 never executed
    #####:  274:            printf("Result %d\n\n", testState.handCount[1]);
call    0 never executed
        -:  275:        }
        -:  276:        else
        -:  277:        {
        1:  278:            printf("TEST #2: Other Player Hand Count Test Passed.\n\n");
call    0 returned 100%
        1:  279:            printf("Expected: 4\n");
call    0 returned 100%
        1:  280:            printf("Result: %d\n", testState.handCount[1]);
call    0 returned 100%
        -:  281:
        -:  282:        }
        -:  283:    }
        -:  284:
        -:  285:    // refactored bug should increase number of cards to 6/7, but it does not.
        -:  286:
        -:  287:
        1:  288:    if(allTestsPassed)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  289:    {
    #####:  290:        printf("All tests passed. Function works perfectly!\n");
call    0 never executed
        -:  291:    }
        -:  292:    else
        -:  293:    {
        1:  294:        printf("One or more tests failed! Please review results and revise code.\n");
call    0 returned 100%
        -:  295:    }
        -:  296:
        1:  297:	return 0;
        -:  298:}
